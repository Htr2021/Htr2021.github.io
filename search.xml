<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/01/hello-world/</url>
    <content><![CDATA[<h2 id="Hexo在github上建站"><a href="#Hexo在github上建站" class="headerlink" title="Hexo在github上建站"></a>Hexo在github上建站</h2><h3 id="建站缘由"><a href="#建站缘由" class="headerlink" title="建站缘由"></a>建站缘由</h3><blockquote>
<p>故事的起因是这样的，本本嘛，作为一个刚入职的程序猿，在查阅资料的时候，邂逅了<a href="https://www.cnblogs.com/wmyskxz/">我没有三颗心脏</a>的博客，当场就被博客首页的效果吸引住了，然后就有了一种我也想拥有这么优美的界面的想法。</p>
<p>幸运的是，我在博客里找到了是个开源项目，开源项目我熟呀，clone一下不就可以膜拜大佬的代码了么（可以直接运行了么）然后我到了<a href="https://volantis.js.org/">Volantis官网</a></p>
<p>那个时候的我，还是不太清楚hexo和主题的关系的，在没有看明白hexo是个什么东西的情况下运行了volantis，然后…，噩梦开始：node一直报错，我开始怀疑我clone的github仓库是不是少文件。。。</p>
<p>花了好久，我才知道主题的文档需要先阅读<a href="https://hexo.io/zh-cn/docs/">Hexo文档</a>的，毕竟主题依赖于hexo…</p>
<p>再然后，我就用了<a href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer主题</a>一切顺利，成功搭建起来，于是我写下了我的第一篇博客。</p>
</blockquote>
<h3 id="建站过程"><a href="#建站过程" class="headerlink" title="建站过程"></a>建站过程</h3><p><a href="https://www.cnblogs.com/trista222/p/8017300.html">搭建过程</a></p>
<p><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p>
<p><a href="https://shen-yu.gitee.io/2019/ayer/">Ayer主题文档</a></p>
<h3 id="搭建-运行-遇到的问题"><a href="#搭建-运行-遇到的问题" class="headerlink" title="搭建-运行 遇到的问题"></a>搭建-运行 遇到的问题</h3><ol>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>运行的时候显示很多的warnings</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_42405223/article/details/106270431">解决 Hexo 在使用 Node.js 14 时的 Accessing non-existent property ‘xxx’ of module exports inside circular dependency 问题 </a></p>
</blockquote>
</li>
<li><p>运行成功之后，访问categories,tags等标签时无法访问</p>
<blockquote>
<p><a href="https://blog.csdn.net/Winter_chen001/article/details/79719154">hexo categories和tags页面不显示解决办法</a></p>
</blockquote>
</li>
<li><p>在Ayer主题中，刚运行时无法评论</p>
<blockquote>
<p>查看 <strong>_config.ayer.yml</strong> 文件,发现</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud:</span><br><span class="line">    enable: true</span><br><span class="line">    app_id:  # </span><br><span class="line">    app_key: #</span><br></pre></td></tr></table></figure>
<p>嗯，问题找到了，然后就需要去<a href="https://github.com/xCss/Valine">Valine</a>去注册用户，按照<a href="https://valine.js.org/quickstart.html">文档</a>的操作，把<strong>app_id</strong>和<strong>app_key</strong>填上就好了</p>
<ol start="4">
<li><p>hexo默认的文章全部存在\source_posts\一个文件夹下面，文章一多就不方便管理。<br>解决方法<a href="https://blog.waitung.cn/2018/06/18/hexo-arrange.html">对hexo的文章整理</a></p>
</li>
<li><p>hexo+markdown 导入图片失败<br>解决方法<a href="https://blog.csdn.net/qq_43401552/article/details/104805466">Hexo+markdown之引用图片方法汇集</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>本站搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>ayer</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ入门-2</title>
    <url>/2021/09/02/RabbitMQ%E5%85%A5%E9%97%A8-2/</url>
    <content><![CDATA[<h3 id="RabbitMQ整体模型"><a href="#RabbitMQ整体模型" class="headerlink" title="RabbitMQ整体模型"></a>RabbitMQ整体模型</h3><p>RabbitMQ整体上说，是一个生产者消费者模型，负责接收，存储和转发消息，从计算机的角度来说，更像一个交换机模型</p>
<blockquote>
<p><img src="img.png" alt="RabbitMQ整体模型"></p>
</blockquote>
<h3 id="RabbitMQ概念介绍"><a href="#RabbitMQ概念介绍" class="headerlink" title="RabbitMQ概念介绍"></a>RabbitMQ概念介绍</h3><p>**Producer(生产者):**生产者创建消息，发送消息体(payload)和标签(label)</p>
<blockquote>
<p>消息体：一般是带有业务逻辑的json<br>标签：交换器名称和路由键</p>
</blockquote>
<p><strong>Consumer(消费者)：</strong>消费者值消费消息体，消息路由的时候，标签会被丢弃，消费者不知道消息的生产者是谁<br><strong>Broker(消息队列的服务节点)：</strong>对外就是消息队列</p>
<blockquote>
<p><img src="img_1.png" alt="消息队列的运转过程"></p>
</blockquote>
<p><strong>Queue(队列)：</strong>RabbitMQ内部对象，存储信息</p>
<blockquote>
<p>RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。<br>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）<br>RabbitMQ 不支持队列层面的广播消费，如果需要广播消费，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做</p>
</blockquote>
<p><strong>Exchange(交换器)：</strong></p>
<blockquote>
<p>生产者将消息发送到 Exchange，由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。<br><img src="img_1.png" alt="交换器"></p>
</blockquote>
<p><strong>RoutingKey(路由键):</strong></p>
<blockquote>
<p>生产者把消息发送给交换机的时候指定的字段，通过这个字段决定与消息发送到哪个队列(BindingKey)</p>
</blockquote>
<p><strong>Binding(绑定):</strong></p>
<blockquote>
<p>将交换器和队列关联起来</p>
</blockquote>
<h4 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h4><p>RabbitMQ 常用的交换器类型有 fanout、direct、topic、headers 这四种。AMQP 协议里还提到另外两种类型：System 和自定义，这里不予描述。不同的类型绑定时具有不同的策略</p>
<ol>
<li>fanout<br>和RoutingKey,BindingKey无关，消息发送到与交换机绑定的所有队列中</li>
<li>direct<br>消息发送到和RoutingKey和BindingKey完全匹配的队列中</li>
<li>topic<br>在前者的基础上做了类似正则表达式的拓展，用规则匹配取代了完全匹配</li>
<li>headers<br>和RoutingKey,BindingKey无关，根据发送的消息内容中的 headers 属性进行匹配，性能较差，不实用</li>
</ol>
<h3 id="RabbitMQ-运转流程"><a href="#RabbitMQ-运转流程" class="headerlink" title="RabbitMQ 运转流程"></a>RabbitMQ 运转流程</h3><p><strong>生产者发送消息的时候：</strong></p>
<ol>
<li>生产者连接到 RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）</li>
<li>生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等（详细内</li>
<li>生产者声明一个队列并设置相关属性，比如是否排他、是否持久化、是否自动删除等</li>
<li>生产者通过路由键将交换器和队列绑定起来</li>
<li>生产者发送消息至 RabbitMQ Broker，其中包含路由键、交换器等信息</li>
<li>相应的交换器根据接收到的路由键查找相匹配的队列。</li>
<li>如果找到，则将从生产者发送过来的消息存入相应的队列中。</li>
<li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ol>
<p><strong>消费者接收消息的过程：</strong></p>
<ol>
<li>消费者连接到 RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。</li>
<li>消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数,以及做一些准备工作</li>
<li>等待 RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。</li>
<li>消费者确认（ack）接收到的消息。</li>
<li>RabbitMQ 从队列中删除相应已经被确认的消息。</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ初体验-1</title>
    <url>/2021/09/02/RabbitMQ%E5%88%9D%E4%BD%93%E9%AA%8C-1/</url>
    <content><![CDATA[<h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><p>分布式系统中的一种消息传递装置</p>
<h4 id="传递模式"><a href="#传递模式" class="headerlink" title="传递模式"></a>传递模式</h4><p>发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者。</p>
<ol>
<li>点对点模式<blockquote>
<p>点对点模式是基于队列的，生产者发送信息到队列，消费者从队列接受消息!<br><img src="iqlde9d8x0.jpg" alt="点对点"><br><strong>特点</strong>： 不可重复消费</p>
</blockquote>
</li>
<li>发布/订阅模式<blockquote>
<p>消息发布者把消息发布到某个主题，消息订阅者从主题获取消息<br><img src="k1o8gjrymm.jpg" alt="多订阅"><br><strong>特点</strong>：可重复消费</p>
</blockquote>
</li>
</ol>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li><strong>解耦</strong>：在编辑代码的时候，不需要考虑另一边怎么设计，直接和消息队列交互就可以</li>
<li><strong>冗余（存储）</strong>：需要处理系统明确的表示消息被处理之后，消息才能被消息队列删除</li>
<li><strong>拓展性</strong>：解耦之后拓展性自然提高</li>
<li><strong>削峰</strong>：起到缓冲的作用，降低服务器的峰值的需求</li>
<li><strong>可恢复性</strong>：生产者或消费者失效时，其它系统任然可以运行</li>
<li><strong>顺序保证</strong>：消息队列确保一定程度上的顺序性</li>
<li><strong>异步通信</strong>：后台任务或者异步任务，起到监听的效果</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2021/09/06/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="docker使用命令"><a href="#docker使用命令" class="headerlink" title="docker使用命令"></a>docker使用命令</h2><h3 id="在部署docker主要使用的命令"><a href="#在部署docker主要使用的命令" class="headerlink" title="在部署docker主要使用的命令"></a>在部署docker主要使用的命令</h3><p>docker network ls<br>docker exec -it 775c7c9ee1e1 /bin/bash  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署vsftpd</title>
    <url>/2021/09/08/docker%E9%83%A8%E7%BD%B2vsftpd/</url>
    <content><![CDATA[<h2 id="docker-compose-部署vsftpd"><a href="#docker-compose-部署vsftpd" class="headerlink" title="docker-compose 部署vsftpd"></a>docker-compose 部署vsftpd</h2><p>这里使用<a href="https://hub.docker.com/r/fauria/vsftpd">fauria/vsftpd</a></p>
<h3 id="docker-run运行"><a href="#docker-run运行" class="headerlink" title="docker run运行"></a>docker run运行</h3><p>使用 <code>docker pull fauria/vsftpd</code>拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -v /data/docker/ftp3/vsftpd:/home/vsftpd -p 20:20 -p 21:21 -p 8430-8440:8430-8440 -e </span><br><span class="line">FTP_USER=test -e FTP_PASS=test -e PASV_ADDRESS=x.x.x.x -e PASV_MIN_PORT=8430 -e PASV_MAX_PORT=8440 --name </span><br><span class="line">vsftpd --restart=always fauria/vsftpd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功之后使用浏览器访问<a href="ftp://test:test@x.x.x.x:x">ftp://test:test@x.x.x.x:21</a>其中x.x.x.x是自己的IP，test,test分别是账号和密码<br>或者使用ftp客户端工具选择FTP协议，取消使用被动模式即可访问<br>如果希望修改端口，请看下面</p>
</blockquote>
<h3 id="docker-compose-up运行"><a href="#docker-compose-up运行" class="headerlink" title="docker-compose up运行"></a>docker-compose up运行</h3><p>docker-compose 就没什么好说的,运行就完事</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:          </span><br><span class="line">    ftp:</span><br><span class="line">        image: fauria/vsftpd</span><br><span class="line">        container_name: vsftpd</span><br><span class="line">        restart: always </span><br><span class="line">        networks:</span><br><span class="line">            mynetwork:</span><br><span class="line">                ipv4_address: 172.18.0.8</span><br><span class="line">        ports:</span><br><span class="line">             - &quot;8420:8420&quot;</span><br><span class="line">             - &quot;8421:8421&quot;</span><br><span class="line">             - &quot;8430-8440:8430-8440&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /data/docker/ftp3/vsftpd:/home/vsftpd</span><br><span class="line">            - /data/docker/ftp3/conf/vsftpd.conf:/etc/vsftpd/vsftpd.conf</span><br><span class="line">            - /data/docker/ftp3/conf/services:/etc/services:ro</span><br><span class="line">        environment:</span><br><span class="line">            FTP_USER: test </span><br><span class="line">            FTP_PASS: test </span><br><span class="line">            PASV_ADDRESS: x.x.x.x</span><br><span class="line">            PASV_MIN_PORT: 8430 </span><br><span class="line">            PASV_MAX_PORT: 8440 </span><br><span class="line">         </span><br><span class="line">networks:</span><br><span class="line">  mynetwork:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和docker run的方法相比，这里修改了端口号，所以把容器内的vsftpd.conf和services文件映射出来方便修改<br>在vsftpd.conf文件中需要增加 <code>listen_port=8421 pasv_enable=YES</code>两行<br>在services文件中需要将 ftp 21/tcp 改为 ftp 801/tcp , ftp 21/udp 改为 ftp 801/udp<br>之后启动即可<br>常规下21端口容易遭到别人的扫描、带来了一定程度的不安全。所以，最好的就是把21端口修改掉。<br>将docker-compose修改的内容对应带docker run的参数就可以了 </p>
</blockquote>
<h2 id="有时间补充"><a href="#有时间补充" class="headerlink" title="有时间补充"></a>有时间补充</h2><ul>
<li>可以看看ftp使用相关内容</li>
<li>可以看看ftp用户创建文件夹和相关映射的添加</li>
<li><a href="https://hub.docker.com/r/fauria/vsftpd">官网</a>上参数的作用</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>运维</tag>
        <tag>ftp</tag>
        <tag>vsftpd</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安装Hyper-V并搭建docker+php+nginx+mysql</title>
    <url>/2021/09/03/windows%E5%AE%89%E8%A3%85Hyper-V+ubuntu/</url>
    <content><![CDATA[<h2 id="Windows10家庭版安装ubuntu"><a href="#Windows10家庭版安装ubuntu" class="headerlink" title="Windows10家庭版安装ubuntu"></a>Windows10家庭版安装ubuntu</h2><h3 id="安装Hyper-V"><a href="#安装Hyper-V" class="headerlink" title="安装Hyper-V"></a>安装Hyper-V</h3><p><a href="https://blog.csdn.net/yuyuking/article/details/103890195">参考博文</a><br>把下面代码保存为.bat文件，用管理员运行，重启之后，就可以在win+S 中搜索到Hyper-V</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hyper-v.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure>

<h3 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h3><p><a href="https://zhuanlan.zhihu.com/p/128640396">参考博文</a><br>基本就是按照操作一步一步点下来。<br>MSDN好像没有ubuntu的镜像了，可以点击<a href="http://mirrors.163.com/ubuntu-releases">网易开源镜像站</a>下载<br>启动之后，会遇到这样的问题，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hyper-V™</span><br><span class="line">Uirtual Machine Boot Su_ary</span><br><span class="line"></span><br><span class="line">1.SCSI Disk (0,0)No UEFI-compatible file system uas found.</span><br><span class="line"></span><br><span class="line">2.Network Adapter (OO155DO6E40O) DHCP failed.</span><br><span class="line"></span><br><span class="line">3.SCSI DUD (0,1)No UEFI-compatible file system uas found.</span><br><span class="line"></span><br><span class="line">No operating system was loaded. Press a Key to retry the boot sequence...</span><br><span class="line">Note： Configuration changes nay require the virtual Machine to be reset.</span><br></pre></td></tr></table></figure>

<p>把虚拟机启动时启用安全启动的勾去掉。<a href="https://tieba.baidu.com/p/5587795237?red_tag=0742118433">解决方法</a></p>
<h2 id="linux安装docker"><a href="#linux安装docker" class="headerlink" title="linux安装docker"></a>linux安装docker</h2><p>安装方法<a href="https://www.cnblogs.com/kingsonfu/p/11576797.html">参考博文</a><br>使用的yum源安装</p>
<ol>
<li>查看是否已安装docker<br><code>yum list installed | grep docker</code></li>
<li>安装docker<br><code>yum -y install docker</code></li>
<li>启动docker<br><code>systemctl start docker</code></li>
<li>查看docker状态<br><code> systemctl status docker</code><br>如果出现下面代表安装成功<br><img src="img.png" alt="安装成功"></li>
<li>可以将docker设置为开机自启动<br><code>systemctl enable docker;</code></li>
</ol>
<blockquote>
<p>建议使用<a href="https://docs.docker.com/engine/install/centos/">官网安装</a></p>
</blockquote>
<h2 id="docker-安装php-nginx-mysql"><a href="#docker-安装php-nginx-mysql" class="headerlink" title="docker 安装php+nginx+mysql"></a>docker 安装php+nginx+mysql</h2><h3 id="获取镜像image"><a href="#获取镜像image" class="headerlink" title="获取镜像image"></a>获取镜像image</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7      # 拉取 mysql 5.7</span><br><span class="line">docker nginx               # 拉取 nginx </span><br><span class="line">docker pull php:5.6-fpm    # 拉取 php </span><br></pre></td></tr></table></figure>
<p>docker images              # 查看安装镜像</p>
<h3 id="普通运行"><a href="#普通运行" class="headerlink" title="普通运行"></a>普通运行</h3><p><code>docker run -p 对外暴露的端口:容器内的端口 --name 容器名 -e 配置信息=内容 -v 主机目录:容器目录 -d 镜像名</code><br>使用 <code>docker ps</code> || <code>docker ps -a</code> 查看运行||全部容器</p>
<h3 id="docker-compose运行"><a href="#docker-compose运行" class="headerlink" title="docker-compose运行"></a>docker-compose运行</h3><p>文件模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2.0&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    restart: always</span><br><span class="line">    image: nginx:1.11.6-alpine</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">      - 80:80</span><br><span class="line">      - 443:443</span><br><span class="line">    volumes:</span><br><span class="line">      - ./conf.d:/etc/nginx/conf.d</span><br><span class="line">      - ./log:/var/log/nginx</span><br><span class="line">      - ./www:/var/www</span><br><span class="line">      - /etc/letsencrypt:/etc/letsencrypt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong><br><strong>version</strong>：版本号</p>
<p><strong>service</strong>：就是要定义的docker容器</p>
<p><strong>nginx</strong>:容器的名称</p>
<p><strong>restart</strong>：设置为always，表明此容器应该在停止的情况下总是重启，比如，服务器启动时，这个容器就跟着启动，不用手动启动，服务器启动之后，进入到docker-compose.yml文件路径下，执行docker-compose ps可以看到，该容器正在运行。</p>
<p><strong>image</strong>：这个是需要依赖的容器，也就是nginx软件，可以到docker官方镜像上找到最新版的镜像。</p>
<p><strong>ports</strong>：端口映射。比如： - 8080:80，表示容器内运行着的端口是80，把端口暴露给8080端口，从外面访问的是8080端口，就能自动映射到80端口上。</p>
<p><strong>volumes</strong>:文件映射。表示数据、配置文件等存放的位置。（- . 这个表示docker-compose.yml当前目录位置开始创建这个文件</p>
<h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><p>如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因：</p>
<ul>
<li>防火墙拦截<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开放端口：</span><br><span class="line">$ systemctl status firewalld</span><br><span class="line">$ firewall-cmd  --zone=public --add-port=3306/tcp -permanent</span><br><span class="line">$ firewall-cmd  --reload</span><br><span class="line"># 关闭防火墙：</span><br><span class="line">$ sudo systemctl stop firewalld</span><br></pre></td></tr></table></figure></li>
<li>需要在docker本地客户端设置远程访问账号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker exec -it mysql bash</span><br><span class="line">$ mysql -uroot -p123456</span><br><span class="line">mysql&gt; grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;</span><br></pre></td></tr></table></figure>
原理：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改）</span><br><span class="line"></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; select host,user,password from user;</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| host                    | user      | password                                                                 |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| localhost              | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |</span><br><span class="line">| 192.168.1.1            | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; grant all privileges  on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select host,user,password from user;</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| host                    | user      | password                                                                 |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| localhost              | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |</span><br><span class="line">| 192.168.1.1            | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |</span><br><span class="line">| %                       | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><del>第一步下载：</del><br><del><code>curl -L https://get.daocloud.io/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` &gt;  /usr/local/bin/docker-compose</code></del><br><del>第二步赋权：</del><br><del><code>chmod a+x /usr/local/bin/docker-compose</code></del><br><del>第三步查看版本：</del><br><del><code>docker-compose --version</code></del><blockquote>
<p>上面的方法在部署之后，使用docker-compose部署会出现端口占用的错误，且物理机，虚拟机端口并没有被占用<br>在一段时间的问题定位之后，发现是安装的docker-compose有问题，所以建议使官网安装<a href="https://docs.docker.com/compose/install/">安装地址</a><br>步骤和上方基本相同，第一步下载的地址发生了改变</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>安装netstat<br><code>yum -y install net-tools </code><br><a href="https://hub.docker.com/">docker-hub地址</a><br><a href="https://docs.docker.com/">docker-文档地址</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>运维</tag>
        <tag>docker-compose</tag>
        <tag>虚拟机</tag>
        <tag>Hyper-V</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose.yml配置文件详解</title>
    <url>/2021/09/06/docker-compose-yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
