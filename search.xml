<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/01/hello-world/</url>
    <content><![CDATA[<h2 id="Hexo在github上建站"><a href="#Hexo在github上建站" class="headerlink" title="Hexo在github上建站"></a>Hexo在github上建站</h2><h3 id="建站缘由"><a href="#建站缘由" class="headerlink" title="建站缘由"></a>建站缘由</h3><blockquote>
<p>故事的起因是这样的，本本嘛，作为一个刚入职的程序猿，在查阅资料的时候，邂逅了<a href="https://www.cnblogs.com/wmyskxz/">我没有三颗心脏</a>的博客，当场就被博客首页的效果吸引住了，然后就有了一种我也想拥有这么优美的界面的想法。</p>
<p>幸运的是，我在博客里找到了是个开源项目，开源项目我熟呀，clone一下不就可以膜拜大佬的代码了么（可以直接运行了么）然后我到了<a href="https://volantis.js.org/">Volantis官网</a></p>
<p>那个时候的我，还是不太清楚hexo和主题的关系的，在没有看明白hexo是个什么东西的情况下运行了volantis，然后…，噩梦开始：node一直报错，我开始怀疑我clone的github仓库是不是少文件。。。</p>
<p>花了好久，我才知道主题的文档需要先阅读<a href="https://hexo.io/zh-cn/docs/">Hexo文档</a>的，毕竟主题依赖于hexo…</p>
<p>再然后，我就用了<a href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer主题</a>一切顺利，成功搭建起来，于是我写下了我的第一篇博客。</p>
</blockquote>
<h3 id="建站过程"><a href="#建站过程" class="headerlink" title="建站过程"></a>建站过程</h3><p><a href="https://www.cnblogs.com/trista222/p/8017300.html">搭建过程</a></p>
<p><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p>
<p><a href="https://shen-yu.gitee.io/2019/ayer/">Ayer主题文档</a></p>
<h3 id="搭建-运行-遇到的问题"><a href="#搭建-运行-遇到的问题" class="headerlink" title="搭建-运行 遇到的问题"></a>搭建-运行 遇到的问题</h3><ol>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>运行的时候显示很多的warnings</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_42405223/article/details/106270431">解决 Hexo 在使用 Node.js 14 时的 Accessing non-existent property ‘xxx’ of module exports inside circular dependency 问题 </a></p>
</blockquote>
</li>
<li><p>运行成功之后，访问categories,tags等标签时无法访问</p>
<blockquote>
<p><a href="https://blog.csdn.net/Winter_chen001/article/details/79719154">hexo categories和tags页面不显示解决办法</a></p>
</blockquote>
</li>
<li><p>在Ayer主题中，刚运行时无法评论</p>
<blockquote>
<p>查看 <strong>_config.ayer.yml</strong> 文件,发现</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud:</span><br><span class="line">    enable: true</span><br><span class="line">    app_id:  # </span><br><span class="line">    app_key: #</span><br></pre></td></tr></table></figure>
<p>嗯，问题找到了，然后就需要去<a href="https://github.com/xCss/Valine">Valine</a>去注册用户，按照<a href="https://valine.js.org/quickstart.html">文档</a>的操作，把<strong>app_id</strong>和<strong>app_key</strong>填上就好了</p>
<ol start="4">
<li><p>hexo默认的文章全部存在\source_posts\一个文件夹下面，文章一多就不方便管理。<br>解决方法<a href="https://blog.waitung.cn/2018/06/18/hexo-arrange.html">对hexo的文章整理</a></p>
</li>
<li><p>hexo+markdown 导入图片失败<br>解决方法<a href="https://blog.csdn.net/qq_43401552/article/details/104805466">Hexo+markdown之引用图片方法汇集</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>本站搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>ayer</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat入门-安装</title>
    <url>/2021/10/18/mycat%E5%85%A5%E9%97%A8-3/</url>
    <content><![CDATA[<p><a href="https://www.yuque.com/ccazhw/gl7qp9/pbegu1">官网-如何安装mycat</a></p>
<h1 id="docker安装MyCat"><a href="#docker安装MyCat" class="headerlink" title="docker安装MyCat"></a>docker安装MyCat</h1><p>mycat版本1.6.7.x,安装mycat之前需要部署好数据库集群，可参考<a href="https://www.yuque.com/r/goto?url=https://github.com/AlphaYu/Adnc/tree/master/doc/mariadb">mariadb基于GTID主从复制搭建</a></p>
<h2 id="下载mycat安装包"><a href="#下载mycat安装包" class="headerlink" title="下载mycat安装包"></a>下载mycat安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建目录</span></span><br><span class="line">mkdir /root/data/mycat</span><br><span class="line"><span class="meta">#</span><span class="bash">切换目录</span></span><br><span class="line">cd /root/data/mycat</span><br><span class="line"><span class="meta">#</span><span class="bash">下载mycat release1.6.7.6到当前目录</span></span><br><span class="line">wget http://dl.mycat.org.cn/1.6.7.6/20201126013625/Mycat-server-1.6.7.6-release-20201126013625-linux.tar.gz</span><br><span class="line">mv Mycat-server-1.6.7.6-release-20201126013625-linux.tar.gz mycat1.6.7.6.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">解压conf目录到当前目录，因为使用docker直接挂载conf目录会报错，mycat启动时需要依赖conf目录中的文件。</span></span><br><span class="line">tar -zxvf mycat1.6.7.6.tar.gz -C /root/data/ mycat/conf</span><br></pre></td></tr></table></figure>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>调整/root/data/mycat/conf中server.xml 与 schema.xml 两个核心配置文件。</p>
<ul>
<li>server.xml<a href="https://www.yuque.com/r/goto?url=https://github.com/AlphaYu/Adnc/blob/master/doc/mycat/server.xml">参考</a></li>
<li>schema.xml<a href="https://github.com/AlphaYu/Adnc/blob/master/doc/mycat/schema.xml">参考</a></li>
<li>server.xml 关键节点介绍<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mycat的账号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>alpha.mycat<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 该账号可以访问的逻辑库,对应schema.xml文件的schema节点的name--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>adnc_usr,adnc_maint,adnc_cus<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>schema.xml 关键节点介绍<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置3个逻辑库--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;adnc_usr&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn_usr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;adnc_maint&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn_maint&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;adnc_cus&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn_cus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 逻辑库对应的真实数据库--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn_usr&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dh_adnc&quot;</span> <span class="attr">database</span>=<span class="string">&quot;adnc_usr&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn_maint&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dh_adnc&quot;</span> <span class="attr">database</span>=<span class="string">&quot;adnc_maint&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn_cus&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dh_adnc&quot;</span> <span class="attr">database</span>=<span class="string">&quot;adnc_cus&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--真实数据库所在的服务器地址，这里配置了1主2从。主服务器(hostM1)宕机会自动切换到(hostS1) --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dh_adnc&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;172.20.0.11:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;alpha.abc&quot;</span> &gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;172.20.0.13:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;alpha.abc&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;172.20.0.12:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;alpha.abc&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
详情配置可参考 <a href="http://www.mycat.org.cn/document/mycat-definitive-guide.pdf">mycat权威指南</a><h2 id="下载dockerfile"><a href="#下载dockerfile" class="headerlink" title="下载dockerfile"></a>下载dockerfile</h2>MyCat官方没有提供docker镜像<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载dockerfile文件到当前目录</span></span><br><span class="line">wget https://raw.githubusercontent.com/AlphaYu/Adnc/master/doc/mycat/Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash">如果下载失败，请手动下载并上传到/root/data/mycat目录，文件地址如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash">https://github.com/AlphaYu/Adnc/blob/master/doc/mycat/Dockerfile</span></span><br></pre></td></tr></table></figure>
或者粘贴<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-stretch</span><br><span class="line"></span><br><span class="line">ADD http://dl.mycat.org.cn/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz /usr/local</span><br><span class="line">RUN cd /usr/local &amp;&amp; tar -zxvf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz &amp;&amp; ls -lna</span><br><span class="line"></span><br><span class="line">ENV MYCAT_HOME=/usr/local/mycat</span><br><span class="line">WORKDIR /usr/local/mycat</span><br><span class="line"></span><br><span class="line">ENV TZ Asia/Shanghai</span><br><span class="line"></span><br><span class="line">EXPOSE 8066 9066</span><br><span class="line"></span><br><span class="line">CMD [&quot;/usr/local/mycat/bin/mycat&quot;, &quot;console&quot;,&quot;&amp;&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="创建mycat镜像和容器"><a href="#创建mycat镜像和容器" class="headerlink" title="创建mycat镜像和容器"></a>创建mycat镜像和容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建镜像文件</span></span><br><span class="line">docker build -t mycat:1.6.7.6 .</span><br><span class="line"><span class="meta">#</span><span class="bash">运行容器并挂载配置文件目录与日志目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-v /root/data/mycat/conf:/usr/<span class="built_in">local</span>/mycat/conf 挂载配置文件目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-v /root/data/mycat/logs:/usr/<span class="built_in">local</span>/mycat/logs 挂载日志目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --network=adnc_net --ip 172.20.0.16  adnc_net是自建的bridge网络，如果使用docker默认网络，不需要这段</span></span><br><span class="line">docker run --privileged=true -p 8066:8066 -p 9066:9066 --name mycat -v /root/data/mycat/conf:/usr/local/mycat/conf -v /root/data/mycat/logs:/usr/local/mycat/logs --network=adnc_net --ip 172.20.0.16 -d mycat:1.6.7.6</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入mariadb/mysql容器</span></span><br><span class="line">docker exec -it mariadb01 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录mycat,172.20.0.16 是指mycat容器的Ip地址，如果容器没有指定固定Ip，你的可能不一样，请注意。</span></span><br><span class="line">mysql -uroot -palpha.mycat -P8066 -h172.20.0.16</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 多次执行下面的sql,观察hostname的变化。</span></span><br><span class="line">select @@hostname;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>MyCat</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>php-fpm简介</title>
    <url>/2021/10/18/php-fpm%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>随笔-Docker</title>
    <url>/2021/10/20/%E9%9A%8F%E7%AC%94-Docker/</url>
    <content><![CDATA[<h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h3><p>运行docker build的时候需要在新建的文件夹下进行，因为build的同时会将当前目录内容发送到Dockerdaemon<br><code>Sending build context to Docker daemon 40.309 GB</code><br>会造成时间和流量的损失</p>
<h3 id="添加用户到docker用户组"><a href="#添加用户到docker用户组" class="headerlink" title="添加用户到docker用户组"></a>添加用户到docker用户组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加用户(默认会在/home/下创建你的文件夹)</span></span><br><span class="line">useradd htr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户密码</span></span><br><span class="line">passwd htr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker用户组，一般已存在，不需要执行</span></span><br><span class="line">cat /etc/group</span><br><span class="line">sudo groupadd docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加用户到工作组</span></span><br><span class="line">usermod -a -G docker htr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试是否可以使用docker(需要重新登陆用户)</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-习惯</title>
    <url>/2021/10/20/%E9%9A%8F%E7%AC%94-%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>随笔-常识</title>
    <url>/2021/10/18/%E9%9A%8F%E7%AC%94-%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="word文件对比"><a href="#word文件对比" class="headerlink" title="word文件对比"></a>word文件对比</h3><p><a href="https://www.scootersoftware.com/download.php">Beyond Compare</a><br>支持常用的word和pdf文件的对比，会帮你高亮标出版本差异。<br>需要自己保留文件的版本，然后手动上传进行对比，正版收费，但是网上可以down到破解版<br><a href="https://www.cnblogs.com/xifengxixia/p/11051718.html">破解方法</a><br>方法1：</p>
<blockquote>
<p>安装目录下找到 BCUnrar.dll 重命名</p>
</blockquote>
<p>方法2：</p>
<blockquote>
<p>win+R regedit<br>删除 HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare 4\CacheId</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="耦合度"><a href="#耦合度" class="headerlink" title="耦合度"></a>耦合度</h3><p>耦合度就是某模块（类）与其它模块（类）之间的关联、感知和依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。<br><a href="https://zhuanlan.zhihu.com/p/112580655">传送门</a></p>
<h3 id="端口转发和端口映射"><a href="#端口转发和端口映射" class="headerlink" title="端口转发和端口映射"></a>端口转发和端口映射</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-运维(PHP||JAVA)</title>
    <url>/2021/10/18/%E9%9A%8F%E7%AC%94_php_java/</url>
    <content><![CDATA[<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="Primary-script-unknown"><a href="#Primary-script-unknown" class="headerlink" title="Primary script unknown"></a>Primary script unknown</h3><p>问题再现：配置完PHP-nginx环境之后File not found,查阅日志后有Primary script unknown问题<br>问题原因：php-fpm找不到php文件,php-fpm没有权限读取和执行文件<br>问题解决：</p>
<ul>
<li>找不到文件导致：nginx配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   root        /var/www/html/sns;</span><br><span class="line">   index  index.html index.htm index.php;</span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">	fastcgi_intercept_errors on;</span><br><span class="line">	fastcgi_pass 172.20.0.8:9000; </span><br><span class="line">	fastcgi_index  index.php;</span><br><span class="line">	fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">	include   fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中，root目录写容器中的目录</li>
<li>权限导致：<a href="https://www.jb51.net/article/168244.htm">参考</a><h3 id="PHP的内存限制-Allowed-memory-size-of-134217728-bytes-exhausted"><a href="#PHP的内存限制-Allowed-memory-size-of-134217728-bytes-exhausted" class="headerlink" title="PHP的内存限制 Allowed memory size of 134217728 bytes exhausted"></a>PHP的内存限制 Allowed memory size of 134217728 bytes exhausted</h3>解释是可用内存已耗尽，这关系到PHP的memory_limit的设置问题。<br>1、修改php.ini<br>memory_limit = 128<br>这种方法需要重启服务器，很显然，此方法对虚拟机有限制。</li>
</ul>
<p>2、通过ini_set函数修改配置选项值<br>ini_set (‘memory_limit’, ‘128M’)<br>ini_set (‘memory_limit’, ‘128M’)</p>
<h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h3><p>在IDEA右侧找到Maven，找到要发布的项目，展开Lifecycle，找到package，右键Run Maven Build 在项目target文件加下会生产jar包<br>如果有多个配置文件，打包前需要通过spring.profiles.active 指定使用哪个配置文件</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ初闻-简介</title>
    <url>/2021/09/02/RabbitMQ%E5%88%9D%E9%97%BB-1/</url>
    <content><![CDATA[<h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><p>分布式系统中的一种消息传递装置</p>
<h4 id="传递模式"><a href="#传递模式" class="headerlink" title="传递模式"></a>传递模式</h4><p>发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者。</p>
<ol>
<li>点对点模式<blockquote>
<p>点对点模式是基于队列的，生产者发送信息到队列，消费者从队列接受消息!<br><img src="iqlde9d8x0.jpg" alt="点对点"><br><strong>特点</strong>： 不可重复消费</p>
</blockquote>
</li>
<li>发布/订阅模式<blockquote>
<p>消息发布者把消息发布到某个主题，消息订阅者从主题获取消息<br><img src="k1o8gjrymm.jpg" alt="多订阅"><br><strong>特点</strong>：可重复消费</p>
</blockquote>
</li>
</ol>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li><strong>解耦</strong>：在编辑代码的时候，不需要考虑另一边怎么设计，直接和消息队列交互就可以</li>
<li><strong>冗余（存储）</strong>：需要处理系统明确的表示消息被处理之后，消息才能被消息队列删除</li>
<li><strong>拓展性</strong>：解耦之后拓展性自然提高</li>
<li><strong>削峰</strong>：起到缓冲的作用，降低服务器的峰值的需求</li>
<li><strong>可恢复性</strong>：生产者或消费者失效时，其它系统任然可以运行</li>
<li><strong>顺序保证</strong>：消息队列确保一定程度上的顺序性</li>
<li><strong>异步通信</strong>：后台任务或者异步任务，起到监听的效果</li>
</ol>
<h3 id="RabbitMQ整体模型"><a href="#RabbitMQ整体模型" class="headerlink" title="RabbitMQ整体模型"></a>RabbitMQ整体模型</h3><p>RabbitMQ整体上说，是一个生产者消费者模型，负责接收，存储和转发消息，从计算机的角度来说，更像一个交换机模型</p>
<blockquote>
<p><img src="%E9%9A%8F%E7%AC%94-%E6%95%B0%E6%8D%AE%E5%BA%93/img.png" alt="RabbitMQ整体模型"></p>
</blockquote>
<h3 id="RabbitMQ概念介绍"><a href="#RabbitMQ概念介绍" class="headerlink" title="RabbitMQ概念介绍"></a>RabbitMQ概念介绍</h3><p>**Producer(生产者):**生产者创建消息，发送消息体(payload)和标签(label)</p>
<blockquote>
<p>消息体：一般是带有业务逻辑的json<br>标签：交换器名称和路由键</p>
</blockquote>
<p><strong>Consumer(消费者)：</strong>消费者值消费消息体，消息路由的时候，标签会被丢弃，消费者不知道消息的生产者是谁<br><strong>Broker(消息队列的服务节点)：</strong>对外就是消息队列</p>
<blockquote>
<p><img src="img_1.png" alt="消息队列的运转过程"></p>
</blockquote>
<p><strong>Queue(队列)：</strong>RabbitMQ内部对象，存储信息</p>
<blockquote>
<p>RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。<br>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）<br>RabbitMQ 不支持队列层面的广播消费，如果需要广播消费，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做</p>
</blockquote>
<p><strong>Exchange(交换器)：</strong></p>
<blockquote>
<p>生产者将消息发送到 Exchange，由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。<br><img src="img_1.png" alt="交换器"></p>
</blockquote>
<p><strong>RoutingKey(路由键):</strong></p>
<blockquote>
<p>生产者把消息发送给交换机的时候指定的字段，通过这个字段决定与消息发送到哪个队列(BindingKey)</p>
</blockquote>
<p><strong>Binding(绑定):</strong></p>
<blockquote>
<p>将交换器和队列关联起来</p>
</blockquote>
<h4 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h4><p>RabbitMQ 常用的交换器类型有 fanout、direct、topic、headers 这四种。AMQP 协议里还提到另外两种类型：System 和自定义，这里不予描述。不同的类型绑定时具有不同的策略</p>
<ol>
<li><strong>fanout</strong><br>和RoutingKey,BindingKey无关，消息发送到与交换机绑定的所有队列中</li>
<li><strong>direct</strong><br>消息发送到和RoutingKey和BindingKey完全匹配的队列中</li>
<li><strong>topic</strong><br>在前者的基础上做了类似正则表达式的拓展，用规则匹配取代了完全匹配</li>
<li><strong>headers</strong><br>和RoutingKey,BindingKey无关，根据发送的消息内容中的 headers 属性进行匹配，性能较差，不实用<h4 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h4>RabbitMQ 常用的队列类型有classic 和quorum<br><a href="https://www.rabbitmq.com/quorum-queues.html">对比参考</a></li>
</ol>
<ul>
<li><strong>classic</strong><br> 一般的队列</li>
<li><strong>quorum</strong><br> 增加了容错性和数据安全性，适用于消息丢失对系统产生重大影响的场景<h3 id="RabbitMQ-运转流程"><a href="#RabbitMQ-运转流程" class="headerlink" title="RabbitMQ 运转流程"></a>RabbitMQ 运转流程</h3></li>
<li><em>生产者发送消息的时候：</em>*</li>
</ul>
<ol>
<li>生产者连接到 RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）</li>
<li>生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等（详细内</li>
<li>生产者声明一个队列并设置相关属性，比如是否排他、是否持久化、是否自动删除等</li>
<li>生产者通过路由键将交换器和队列绑定起来</li>
<li>生产者发送消息至 RabbitMQ Broker，其中包含路由键、交换器等信息</li>
<li>相应的交换器根据接收到的路由键查找相匹配的队列。</li>
<li>如果找到，则将从生产者发送过来的消息存入相应的队列中。</li>
<li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ol>
<p><strong>消费者接收消息的过程：</strong></p>
<ol>
<li>消费者连接到 RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。</li>
<li>消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数,以及做一些准备工作</li>
<li>等待 RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。</li>
<li>消费者确认（ack）接收到的消息。</li>
<li>RabbitMQ 从队列中删除相应已经被确认的消息。</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose.yml配置文件</title>
    <url>/2021/09/06/docker-compose-yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="常用的docker-compose-命令"><a href="#常用的docker-compose-命令" class="headerlink" title="常用的docker-compose 命令"></a>常用的docker-compose 命令</h2><h3 id="部署compose应用"><a href="#部署compose应用" class="headerlink" title="部署compose应用"></a>部署compose应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up </span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>-f + compose文件名<br>-d 后台运行</p>
<h3 id="停止docker-compose相关的容器"><a href="#停止docker-compose相关的容器" class="headerlink" title="停止docker-compose相关的容器"></a>停止docker-compose相关的容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose stop </span><br><span class="line"># 容器不会被删除，停止的容器可以通过docker-compose restart 重新启动</span><br></pre></td></tr></table></figure>
<h3 id="删除停止的compose应用"><a href="#删除停止的compose应用" class="headerlink" title="删除停止的compose应用"></a>删除停止的compose应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose rm </span><br><span class="line"># 删除容器和网络，不会删除文件映射和各个容器</span><br></pre></td></tr></table></figure>
<h3 id="重启停止的compose应用"><a href="#重启停止的compose应用" class="headerlink" title="重启停止的compose应用"></a>重启停止的compose应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose restart </span><br><span class="line"># 如果用户在停止该应用后对其进行了变更，那么变更的内容不会反映在重启后的应用中，这时需要重新部署应用使变更生效。</span><br></pre></td></tr></table></figure>
<h3 id="列出compose应用中的各个容器"><a href="#列出compose应用中的各个容器" class="headerlink" title="列出compose应用中的各个容器"></a>列出compose应用中的各个容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose ps</span><br><span class="line"># 输出内容包括当前状态，容器运行的命令和网络端口</span><br></pre></td></tr></table></figure>
<h3 id="停止并删除运行的compose应用"><a href="#停止并删除运行的compose应用" class="headerlink" title="停止并删除运行的compose应用"></a>停止并删除运行的compose应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compse down</span><br><span class="line"># 会删除容器和网络，但不会删除文件映射和镜像</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile</title>
    <url>/2021/09/08/dockerfile/</url>
    <content><![CDATA[<h2 id="docker-build介绍"><a href="#docker-build介绍" class="headerlink" title="docker build介绍"></a>docker build介绍</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><code>docker build -f Dockerfile -t my/php:5.6-fpm-alpine .</code></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>docker build [OPTIONS]  PATH | URL | -</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li>–build-arg=[] :设置镜像创建时的变量；</li>
<li>–cpu-shares :设置 cpu 使用权重；</li>
<li>–cpu-period :限制 CPU CFS周期；</li>
<li>–cpu-quota :限制 CPU CFS配额；</li>
<li>–cpuset-cpus :指定使用的CPU id；</li>
<li>–cpuset-mems :指定使用的内存 id；</li>
<li>–disable-content-trust :忽略校验，默认开启；</li>
<li><strong>-f</strong> :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–isolation :使用容器隔离技术；</li>
<li>–label=[] :设置镜像使用的元数据；</li>
<li>-m :设置内存最大值；</li>
<li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>–no-cache :创建镜像的过程不使用缓存；</li>
<li>–pull :尝试去更新镜像的新版本；</li>
<li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–shm-size :设置/dev/shm的大小，默认值是64M；</li>
<li>–ulimit :Ulimit配置。</li>
<li>–squash :将 Dockerfile 中所有的操作压缩为一层。</li>
<li><strong>–tag</strong>, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li>
<li><strong>–network</strong>: 默认 default。在构建期间设置RUN指令的网络模式</li>
</ul>
<h2 id="dockerfile-语法"><a href="#dockerfile-语法" class="headerlink" title="dockerfile 语法"></a>dockerfile 语法</h2>]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
        <tag>docker build</tag>
        <tag>dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2021/09/06/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="docker使用命令"><a href="#docker使用命令" class="headerlink" title="docker使用命令"></a>docker使用命令</h2><h3 id="常规指令"><a href="#常规指令" class="headerlink" title="常规指令"></a>常规指令</h3><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h4 id="停止docker"><a href="#停止docker" class="headerlink" title="停止docker"></a>停止docker</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<h4 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<h4 id="查看docker信息"><a href="#查看docker信息" class="headerlink" title="查看docker信息"></a>查看docker信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<h4 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="查看已安装的镜像"><a href="#查看已安装的镜像" class="headerlink" title="查看已安装的镜像"></a>查看已安装的镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h4 id="搜索docker-hub上的镜像"><a href="#搜索docker-hub上的镜像" class="headerlink" title="搜索docker hub上的镜像"></a>搜索docker hub上的镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nginx为例</span><br><span class="line">docker serch nginx</span><br></pre></td></tr></table></figure>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nginx[:version]</span><br></pre></td></tr></table></figure>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除单个/多个镜像</span><br><span class="line">docker rmi tomcat[:version]</span><br><span class="line">docker rmi -f 镜像ID</span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br><span class="line"># 删除全部镜像</span><br><span class="line"># docker images -qa 获取全部镜像id</span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure>
<h4 id="修改镜像标签"><a href="#修改镜像标签" class="headerlink" title="修改镜像标签"></a>修改镜像标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 给nginx镜像打标签</span><br><span class="line">docker tag nginx my/nginx:1.0</span><br></pre></td></tr></table></figure>
<h4 id="保存镜像到本地"><a href="#保存镜像到本地" class="headerlink" title="保存镜像到本地"></a>保存镜像到本地</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 保存my/nginx</span><br><span class="line">docker save  my/nginx -o /data/images/mynginx.tar</span><br></pre></td></tr></table></figure>
<h4 id="加载镜像到容器"><a href="#加载镜像到容器" class="headerlink" title="加载镜像到容器"></a>加载镜像到容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load &lt; /home/admin/下载/肺功能部署/images/my_mysql_1.0.tar</span><br></pre></td></tr></table></figure>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run [options] image [command] [arg...]</span><br></pre></td></tr></table></figure>
<h5 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d: 后台运行容器,并返回容器ID</span><br><span class="line"></span><br><span class="line">-i: 以交互式运行容器,通常与-t同时使用</span><br><span class="line"></span><br><span class="line">-p: 端口映射,格式为 主机(宿主)端口:容器端口</span><br><span class="line"></span><br><span class="line">-t: 为容器重新分配一个伪输入终端,通常与-i同时使用</span><br><span class="line"></span><br><span class="line">--name=&quot;name&quot;: 为容器指定一个名称</span><br><span class="line"></span><br><span class="line">--dns 8.8.8.8: 为容器指定一个dns服务器,默认与宿主一致</span><br><span class="line"></span><br><span class="line">--dns-search domain:为容器指定一个DNS域名,默认与宿主一致</span><br><span class="line"></span><br><span class="line">-h &quot;hostname&quot;: 指定容器的hostname</span><br><span class="line"></span><br><span class="line">-e arg=&quot;value&quot;: 设置环境变量</span><br><span class="line"></span><br><span class="line">-env-file=[]:从指定文件读入环境变量</span><br><span class="line"></span><br><span class="line">--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定的cpu运行</span><br><span class="line"></span><br><span class="line">-m: 设置容器使用内存最大值</span><br><span class="line"></span><br><span class="line">--net=&quot;bridge&quot;: 指定容器的网络连接类型,支持bridge/host/none/container四种类型</span><br><span class="line"></span><br><span class="line">--link=[]:添加链接到另外一个容器</span><br><span class="line"></span><br><span class="line">--expose=[]:开放一个端口或一组端口,宿主机使用随机端口映射到开放的端口</span><br></pre></td></tr></table></figure>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -v /my/data/directory:/home/vsftpd -p 20:20 -p 21:21 -p 21100-21110:21100-21110 -e FTP_USER=myuser -e FTP_PASS=mypass -e PASV_ADDRESS=127.0.0.1 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 --name vsftpd --restart=always vsftpd</span><br></pre></td></tr></table></figure>
<h4 id="查看运行的docker容器"><a href="#查看运行的docker容器" class="headerlink" title="查看运行的docker容器"></a>查看运行的docker容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<h5 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示所有容器，包括当前没有运行的容器</span><br><span class="line">-a</span><br><span class="line"># 显示最近创建的容器</span><br><span class="line">-l</span><br><span class="line"># 显示最近创建的N个容器</span><br><span class="line">-n</span><br><span class="line"># 静默模式,只显示容器ID</span><br><span class="line">-q</span><br><span class="line"># 不截断输出</span><br><span class="line">--no-trunc</span><br></pre></td></tr></table></figure>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 /bin/bash</span><br></pre></td></tr></table></figure>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 退出并停止</span><br><span class="line">exit</span><br><span class="line"># 容器不停止退出</span><br><span class="line">ctrl+P+Q</span><br></pre></td></tr></table></figure>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器ID或容器name</span><br><span class="line">docker start $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure>
<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart 容器ID或容器name</span><br><span class="line">docker restart $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure>
<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器ID或容器name</span><br><span class="line">docker stop $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure>
<h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker kill 容器ID或容器name</span><br><span class="line">docker kill $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除已经停止的容器</span><br><span class="line">docker rm 容器ID或容器name </span><br><span class="line"># 强制删除已经停止或正在运行的容器</span><br><span class="line">docker rm -f  容器ID或容器name </span><br><span class="line">#一次性删除所有正在运行的容器</span><br><span class="line">docker rm -f $(docker ps -qa)</span><br></pre></td></tr></table></figure>
<h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker export 5a9229275d3c &gt; myNginx.tar</span><br></pre></td></tr></table></figure>
<h4 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker import myNginx.tar my/nginx:1.0</span><br></pre></td></tr></table></figure>
<h4 id="将文件从容器中拷贝到宿主机"><a href="#将文件从容器中拷贝到宿主机" class="headerlink" title="将文件从容器中拷贝到宿主机"></a>将文件从容器中拷贝到宿主机</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID或容器名称:/文件路径与文件名 宿主机地址</span><br></pre></td></tr></table></figure>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拷贝容器coco的tmp文件夹下的info.txt到宿主机的当前位置</span><br><span class="line">docker cp coco:/tmp/info.txt .</span><br></pre></td></tr></table></figure>
<h4 id="日志命令"><a href="#日志命令" class="headerlink" title="日志命令"></a>日志命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 10 容器ID或容器名称</span><br></pre></td></tr></table></figure>
<h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加入时间戳</span><br><span class="line">-t</span><br><span class="line"># 跟随最新的日志打印</span><br><span class="line">-f</span><br><span class="line"># 输出最后几行的日志</span><br><span class="line">--tail 行数</span><br></pre></td></tr></table></figure>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 10 5b66c8ab957e</span><br></pre></td></tr></table></figure>
<h3 id="network命令"><a href="#network命令" class="headerlink" title="network命令"></a>network命令</h3><h4 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>
<h4 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network create 网络名称</span><br></pre></td></tr></table></figure>
<h4 id="把其它容器添加到网络"><a href="#把其它容器添加到网络" class="headerlink" title="把其它容器添加到网络"></a>把其它容器添加到网络</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network connect 网络名称 容器名称</span><br></pre></td></tr></table></figure>
<h4 id="断开网络"><a href="#断开网络" class="headerlink" title="断开网络"></a>断开网络</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network disconnet 网络名称 容器名称</span><br></pre></td></tr></table></figure>
<h4 id="移除网络"><a href="#移除网络" class="headerlink" title="移除网络"></a>移除网络</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network rm 网络名称</span><br></pre></td></tr></table></figure>
<h4 id="查看网络内部信息"><a href="#查看网络内部信息" class="headerlink" title="查看网络内部信息"></a>查看网络内部信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network inspect 网络名称</span><br></pre></td></tr></table></figure>
<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="免sudo操作docker"><a href="#免sudo操作docker" class="headerlink" title="免sudo操作docker"></a>免sudo操作docker</h3><ol>
<li>如果还没有 docker group 就添加一个：<br><code>sudo groupadd docker</code></li>
<li>将用户加入该 group 内。然后退出并重新登录就生效啦。<br><code>sudo gpasswd -a $&#123;USER&#125; docker</code></li>
<li>重启 docker 服务<br><code>sudo service docker restart</code></li>
<li>切换当前会话到新 group 或者重启 X 会话<br><code>newgrp - docker</code><blockquote>
<p>注意:最后一步是必须的，否则因为 groups 命令获取到的是缓存的组信息，刚添加的组信息未能生效，所以 docker images 执行时同样有错。</p>
</blockquote>
<h3 id="重装docker"><a href="#重装docker" class="headerlink" title="重装docker"></a>重装docker</h3></li>
</ol>
<ul>
<li>停止所有容器<br><code>docker stop $(docker ps -a -q)</code></li>
<li>删除所有容器<br><code>docker rm $(docker ps -a -q)</code></li>
<li>删除所有镜像<br><code>docker rmi $(docker images -q)</code></li>
<li>列出安装过的docker包<br><code>yum list installed | grep docker</code></li>
<li>删除<br><code>yum -y remove docker-ce.x86....  -----删除三次</code></li>
<li>删除镜像和容器<br><code>rm -rf /var/lib/docker</code></li>
<li>卸载旧版本，因为可能存在清除不干净的时候<br><code>yum remove docker docker-common docker-selinux docker-engine</code></li>
</ul>
<h2 id="docker磁盘相关"><a href="#docker磁盘相关" class="headerlink" title="docker磁盘相关"></a>docker磁盘相关</h2><h3 id="docker-overlay目录名寻找容器"><a href="#docker-overlay目录名寻找容器" class="headerlink" title="docker overlay目录名寻找容器"></a>docker overlay目录名寻找容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sc * | sort -rn #查看谁磁盘占用大</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再通过目录名查找容器名：</span></span><br><span class="line">docker ps -q | xargs docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;, &#123;&#123;.Id&#125;&#125;, &#123;&#123;.Name&#125;&#125;, &#123;&#123;.GraphDriver.Data.WorkDir&#125;&#125;&#x27; | grep &quot;bbed8c4cd32f640601c976229c610a5d3ef0ddc5be274acda3699f425dff884a&quot;</span><br><span class="line">[感兴趣可以看看这里](https://blog.csdn.net/styshoo/article/details/60715942)</span><br></pre></td></tr></table></figure>
<h3 id="查看容器占用磁盘大小"><a href="#查看容器占用磁盘大小" class="headerlink" title="查看容器占用磁盘大小"></a>查看容器占用磁盘大小</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system df # 查看镜像，容器，卷大小</span><br><span class="line">docker system df -v # 查看每个镜像，容器，卷大小</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker网络模式</title>
    <url>/2021/09/08/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="docker四种网络模式"><a href="#docker四种网络模式" class="headerlink" title="docker四种网络模式"></a>docker四种网络模式</h2><table>
<thead>
<tr>
<th>Docker网络模式</th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bridge</td>
<td>–net=bridge</td>
<td>默认</td>
</tr>
<tr>
<td>host</td>
<td>–net=host</td>
<td>容器和宿主机共享Network namespace</td>
</tr>
<tr>
<td>container</td>
<td>net=container:NAME_or_ID</td>
<td>容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。</td>
</tr>
<tr>
<td>none</td>
<td>–net=none</td>
<td>容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等</td>
</tr>
</tbody></table>
<h3 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h3><p>Docker进程启动时，会在主机上创建一个docker0的虚拟网桥，然后再把主机上启动的docker容器链接到虚拟网桥上，从docker0子网分配一个ip给容器使用，并设置docker0的ip为容器默认网关<br>bridge模式如下图所示：<br><img src="13618762-f1643a51d313a889.png" alt="bridge模式"></p>
<h3 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h3><p>容器和数组及使用一个Network namespace 容器不会虚拟出自己的网卡和ip，而是使用宿主机的IP和端口，容器的文件系统，进程还是和外部隔离的<br>优点：网络性能比较好 缺点：用过的端口不能复用，网络隔离性不好<br>host模式如下图所示：<br><img src="13618762-a892da42b8ff9342.webp" alt="host模式"></p>
<h3 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h3><p>新创建的容器和指定的容器共用一个namespace，而不是和宿主机共享，两个容器只是网络共享，文件系统，进程还是隔离的<br>container模式如下图所示：<br><img src="13618762-790a69a562a5b358.webp" alt="container模式"></p>
<h3 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h3><p>不为容器进行任何网络设置，封闭的网络能很好的保证容器的安全<br><img src="13618762-3fd41778faebcef5.webp" alt="none模式"></p>
<h2 id="docker-network-create"><a href="#docker-network-create" class="headerlink" title="docker network create"></a>docker network create</h2><p>–subnet=192.168.200.0/24命令指定该网络模式网段范围，其中24代表该网段前24位相同，后8位不同，即该网段范围为：192.168.200.1~192.168.200.254，若该命令改为–subnet=192.168.200.0.16，即该网段范围为：192.168.0.1-192.168.255.254，这个范围就变的很大了。<br><a href="https://blog.csdn.net/zhizhuodewo6/article/details/87706638">参考博文</a><br><a href="https://www.jianshu.com/p/22a7032bb7bd">参考博文：https://www.jianshu.com/p/22a7032bb7bd</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署vsftpd</title>
    <url>/2021/09/08/docker%E9%83%A8%E7%BD%B2vsftpd/</url>
    <content><![CDATA[<h2 id="docker-compose-部署vsftpd"><a href="#docker-compose-部署vsftpd" class="headerlink" title="docker-compose 部署vsftpd"></a>docker-compose 部署vsftpd</h2><p>这里使用<a href="https://hub.docker.com/r/fauria/vsftpd">fauria/vsftpd</a></p>
<h3 id="docker-run运行"><a href="#docker-run运行" class="headerlink" title="docker run运行"></a>docker run运行</h3><p>使用 <code>docker pull fauria/vsftpd</code>拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -v /data/docker/ftp3/vsftpd:/home/vsftpd -p 20:20 -p 21:21 -p 8430-8440:8430-8440 -e </span><br><span class="line">FTP_USER=test -e FTP_PASS=test -e PASV_ADDRESS=x.x.x.x -e PASV_MIN_PORT=8430 -e PASV_MAX_PORT=8440 --name </span><br><span class="line">vsftpd --restart=always fauria/vsftpd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功之后使用浏览器访问<a href="ftp://test:test@x.x.x.x:x">ftp://test:test@x.x.x.x:21</a>其中x.x.x.x是自己的IP，test,test分别是账号和密码<br>或者使用ftp客户端工具选择FTP协议，取消使用被动模式即可访问<br>如果希望修改端口，请看下面</p>
</blockquote>
<h3 id="docker-compose-up运行"><a href="#docker-compose-up运行" class="headerlink" title="docker-compose up运行"></a>docker-compose up运行</h3><p>docker-compose 运行就完事</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:          </span><br><span class="line">    ftp:</span><br><span class="line">        image: fauria/vsftpd</span><br><span class="line">        container_name: vsftpd</span><br><span class="line">        restart: always </span><br><span class="line">        networks:</span><br><span class="line">            mynetwork:</span><br><span class="line">                ipv4_address: 172.18.0.8</span><br><span class="line">        ports:</span><br><span class="line">             - &quot;8420:8420&quot;</span><br><span class="line">             - &quot;8421:8421&quot;</span><br><span class="line">             - &quot;8430-8440:8430-8440&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /data/docker/ftp3/vsftpd:/home/vsftpd</span><br><span class="line">            - /data/docker/ftp3/conf/vsftpd.conf:/etc/vsftpd/vsftpd.conf</span><br><span class="line">            - /data/docker/ftp3/conf/services:/etc/services:ro</span><br><span class="line">        environment:</span><br><span class="line">            FTP_USER: test </span><br><span class="line">            FTP_PASS: test </span><br><span class="line">            PASV_ADDRESS: x.x.x.x</span><br><span class="line">            PASV_MIN_PORT: 8430 </span><br><span class="line">            PASV_MAX_PORT: 8440 </span><br><span class="line">         </span><br><span class="line">networks:</span><br><span class="line">  mynetwork:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和docker run的方法相比，这里修改了端口号，所以把容器内的vsftpd.conf和services文件映射出来方便修改<br>在vsftpd.conf文件中需要增加 <code>listen_port=8421 pasv_enable=YES</code>两行<br>在services文件中需要将 ftp 21/tcp 改为 ftp 801/tcp , ftp 21/udp 改为 ftp 801/udp<br>之后启动即可<br>常规下21端口容易遭到别人的扫描、带来了一定程度的不安全。所以，最好的就是把21端口修改掉。<br>将docker-compose修改的内容对应带docker run的参数就可以了 </p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果无法访问，可以关闭端口防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看防火墙状态=》使用root的身份=》结果为running</span><br><span class="line">firewall-cmd --state</span><br><span class="line">#永久性的开放8421端口</span><br><span class="line">firewall-cmd --add-port=8421/tcp permanent</span><br><span class="line">#重载生效刚才的端口设置</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h2 id="有时间补充"><a href="#有时间补充" class="headerlink" title="有时间补充"></a>有时间补充</h2><ul>
<li>ftp使用相关内容</li>
<li>vsftpd原理</li>
<li>ftp用户创建文件夹和相关映射的添加</li>
<li><a href="https://hub.docker.com/r/fauria/vsftpd">官网</a>上参数的作用</li>
<li>在启动的时候分配了一个子网是干什么的</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>ftp</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>encrypt</title>
    <url>/2021/09/09/encrypt/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e1a81976191c8e6eb021fbc9e7ad666f044f32a369f256494c040c60b3d42fc3">bd25ed9264b080267271e137e33d0ce18f3dbb41a8a4203af98a09ddcdccf6d3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>本站搭建</category>
      </categories>
      <tags>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-SQL注入</title>
    <url>/2021/09/26/mybatis-1/</url>
    <content><![CDATA[<h2 id="MyBatis-是如何解决SQL注入问题的"><a href="#MyBatis-是如何解决SQL注入问题的" class="headerlink" title="MyBatis 是如何解决SQL注入问题的"></a>MyBatis 是如何解决SQL注入问题的</h2><p>在使用mybatis编写SQL时，会遇到<code>#&#123;&#125;</code> 和<code>$&#123;&#125;</code></p>
<ul>
<li><code>#&#123;&#125;</code>在预处理时，会把参数用占位符替代，在预编译之后传入参数(不存在SQL注入)</li>
<li><code>$&#123;&#125;</code>不做预处理，将参数不加修饰放到sql语句中(会产生注入)<br>MyBatis 默认对所有sql进行预编译，底层使用PreparedStatement,先将带有占位符的sql模板发送到mysql服务器，由服务器编译并保留编译结果，然后执行带有真实参数的sql</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyCat入门-基础知识</title>
    <url>/2021/09/22/mycat%E5%85%A5%E9%97%A8-1/</url>
    <content><![CDATA[<p>原文:<a href="https://www.yuque.com/ccazhw/tuacvk/vttsnv">https://www.yuque.com/ccazhw/tuacvk/vttsnv</a></p>
<h2 id="基础知识介绍"><a href="#基础知识介绍" class="headerlink" title="基础知识介绍"></a>基础知识介绍</h2><h3 id="需求由来"><a href="#需求由来" class="headerlink" title="需求由来"></a>需求由来</h3><h4 id="OLTP和OLAP"><a href="#OLTP和OLAP" class="headerlink" title="OLTP和OLAP"></a>OLTP和OLAP</h4><p>谈到数据库，必然会引起这两种处理类型</p>
<ol>
<li><strong>联机事务处理</strong> (OLTP)<br>将原始数据传送到数据中心计算，业务处理，在很短的时间给出处理结果</li>
<li><strong>联机分析处理</strong> (OLAP)<br>多维的方式对数据分析，同数据挖掘工具，统计分析工具使用<table>
<thead>
<tr>
<th></th>
<th>OLTP</th>
<th>OLAP</th>
</tr>
</thead>
<tbody><tr>
<td>系统功能</td>
<td>交易</td>
<td>统计分析</td>
</tr>
<tr>
<td>DB 设计</td>
<td>面向事实交易</td>
<td>面向统计</td>
</tr>
<tr>
<td>数据处理</td>
<td></td>
<td><strong>数据量大</strong></td>
</tr>
<tr>
<td>实时性</td>
<td><strong>实时性高</strong></td>
<td></td>
</tr>
<tr>
<td>事务</td>
<td>强一致性</td>
<td>弱事务</td>
</tr>
<tr>
<td>分析要求</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="关系型数据库和NoSQL数据库"><a href="#关系型数据库和NoSQL数据库" class="headerlink" title="关系型数据库和NoSQL数据库"></a>关系型数据库和NoSQL数据库</h4><ul>
<li><p><strong>关系型数据库</strong><br>建立在关系模型上的数据库，主流有oracle、DB2、MS SQL Server和mysql</p>
</li>
<li><p><strong>NoSQL数据库</strong>(Not only SQL)<br>主要分为临时性键值存储（memcached、Redis）、永久性键值存储（ROMA、Redis）、面向文档的数据库（MongoDB、CouchDB）、面向列的数据库（Cassandra、HBase），每种NoSQL都有其特有的使用场景及优点。</p>
</li>
<li><p>主要是由于随着互联网发展，数据量越来越大，对性能要求越来越高，传统数据库存在着先天性的缺陷，即<strong>单机（单库）性能瓶颈，并且扩展困难</strong>。这样既有单机单库瓶颈，却又扩展困难，自然无法满足日益增长的海量数据存储及其性能要求，所以才会出现了各种不同的NoSQL产品，NoSQL根本性的优势在于在云计算时代，简单、易于大规模分布式扩展，并且读写性能非常高。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>关系型数据库</th>
<th>NoSQL数据库</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>数据关系模型基于关系模型，结构化存储，完整性约束 <br>基于二维表及其之间的联系，需要连接、并、交、差、除等数据操作<br>采用结构化的查询语言（SQL）做数据读写<br>操作需要数据的一致性，需要事务甚至是强一致性</td>
<td>非结构化的存储<br>基于多维关系模型<br>具有特有的使用场景</td>
</tr>
<tr>
<td>优点</td>
<td>保持数据的一致性（事务处理）<br>可以进行join等复杂查询 通用化，技术成熟</td>
<td>高并发，大数据下读写能力较强<br>基本支持分布式，易于扩展，可伸缩<br>简单，弱结构化存储</td>
</tr>
<tr>
<td>缺点</td>
<td>数据读写必须经过sql解析，大量数据、高并发下读写性能不足 对数据做读写，或修改数据结构时需要加锁，影响并发操作<br>无法适应非结构化存储<br>扩展困难<br>昂贵、复杂</td>
<td>join等复杂操作能力较弱<br>事务支持较弱<br>通用性差<br>无完整约束复杂业务场景支持较差</td>
</tr>
</tbody></table>
<p>目前NoSQL只能作为传统数据库的补充而不能将其替代，为了解决传统数据库不支持大规模自动扩展，需要使用第三方软件进行数据切分</p>
<h3 id="数据库切分概述"><a href="#数据库切分概述" class="headerlink" title="数据库切分概述"></a>数据库切分概述</h3><h4 id="数据切分"><a href="#数据切分" class="headerlink" title="数据切分"></a>数据切分</h4><p>将同一数据库中的数据放到多个数据库服务上，以此来降低服务器负载</p>
<h5 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h5><p><strong>将不同的库或表切分到不同的服务中</strong><br>优点：</p>
<ul>
<li>业务简单</li>
<li>系统整合拓展容易</li>
<li>数据维护简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>跨表join需要接口实现，提高了系统的复杂度</li>
<li>存在单库(单表)性能瓶颈</li>
<li>事务处理复杂</li>
</ul>
<h5 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h5><p><strong>将同一表中的不同数据切分到不同服务中</strong><br><img src="img.png" alt="水平切分"><br>常见拆分规则：</p>
<ol>
<li>按ID求模</li>
<li>按时间求模</li>
<li>按特定字段求模</li>
</ol>
<p>优点：</p>
<ul>
<li>拆分规则抽象好，join操作基本可以数据库做；</li>
<li>不存在单表大数据的高并发瓶颈</li>
<li>应用端改造少</li>
<li>提高系统稳定性和负载</li>
</ul>
<p>缺点：</p>
<ul>
<li>拆分规则不好抽象</li>
<li>事务一致性难以解决</li>
<li>数据拓展时维护量大</li>
<li>跨库join时性能较差</li>
</ul>
<h5 id="共同缺点"><a href="#共同缺点" class="headerlink" title="共同缺点"></a>共同缺点</h5><p>在引入多服务后，<strong>数据一致性，跨节点join，分页，多数据源管理</strong>成为了主要的问题<br>针对数据源管理，目前有两种思路：</p>
<ol>
<li>客户端模式(垂直切分)：<br>每个应用程序配置属于自己的数据源</li>
<li>中间代理层(水平切分)：<br>使用MyCat等中间代理层</li>
</ol>
<h5 id="数据切分的基本原则"><a href="#数据切分的基本原则" class="headerlink" title="数据切分的基本原则"></a>数据切分的基本原则</h5><ol>
<li>能不切分尽量不切分</li>
<li>选择合适的切分规则</li>
<li>通过数据冗余或表分组降低跨库join</li>
<li>业务读取尽量少使用多表join</li>
</ol>
<h3 id="常用技术"><a href="#常用技术" class="headerlink" title="常用技术"></a>常用技术</h3><h4 id="主从复制，读写分离"><a href="#主从复制，读写分离" class="headerlink" title="主从复制，读写分离"></a>主从复制，读写分离</h4><p>使用两个以上相同的数据库，一个主，一个从，主数据库操作时，从数据库相应操作<br>主数据库进行写操作，从数据库执行查询操作<br>优点：</p>
<ul>
<li>主数据库出问题时，从数据库起到备用的效果</li>
<li>写操作和读操作在两个服务上，避免写影响读的效率</li>
</ul>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>是一种容灾方案<br>哨兵：特殊模式下的redis服务器，存储本身的信息，主服务器，从服务器的信息<br>用一个或多个哨兵来监视写服务器，如果写服务器挂了，找到合适的从服务器来成为主服务器</p>
<h2 id="MyCat简介"><a href="#MyCat简介" class="headerlink" title="MyCat简介"></a>MyCat简介</h2><p><strong>是什么：</strong>开源的分布式数据库系统，面对前端他是一个数据库代理，面对后端调用mysql原生(Native)协议与多个mysql服务器通信<br><strong>干什么：</strong>分表分库，将大表水平分割成N个小表，存储到不同数据库服务中</p>
<p>到今天(2021/9/24)MyCat后端支持MySQL、SQL Server、Oracle、DB2、PostgreSQL等主流数据库，也支持MongoDB这种新型NoSQL方式的存储</p>
<p><strong>对DBA：</strong>MyCat就是MySQL Server，而MyCat后面连接的MySQL Server，就好象是MySQL的存储引擎,如InnoDB，MyISAM等，因此，MyCat本身并不存储数据，数据是在后端的MySQL上存储的，因此数据可靠性以及事务等都是MySQL保证的，简单的说，MyCat就是MySQL最佳伴侣，它在一定程度上让MySQL拥有了能跟Oracle PK的能力</p>
<p><strong>对软件工程师：</strong>MyCat就是一个近似等于MySQL的数据库服务器，你可以用连接MySQL的方式去连接MyCat（除了端口不同，默认的MyCat端口是8066而非MySQL的3306，因此需要在连接字符串上增加端口信息），大多数情况下，可以用你熟悉的对象映射框架使用MyCat，但建议对于分片表，尽量使用基础的SQL语句，因为这样能达到最佳性能，特别是几千万甚至几百亿条记录的情况下。</p>
<p><strong>对架构师：</strong>MyCat是一个强大的数据库中间件，不仅仅可以用作读写分离、以及分表分库、容灾备份，而且可以用于多租户应用开发、云平台基础设施、让你的架构具备很强的适应性和灵活性，借助于即将发布的MyCat智能优化模块，系统的数据访问瓶颈和热点一目了然，根据这些统计分析数据，你可以自动或手工调整后端存储，将不同的表映射到不同存储引擎上，而整个应用的代码一行也不用改变。</p>
<h3 id="MyCat原理"><a href="#MyCat原理" class="headerlink" title="MyCat原理"></a>MyCat原理</h3><p>拦截用户发送过来的SQL语句，首先对SQL语句做了一些特定的分析：如<strong>分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户</strong>。<br><img src="image008.png" alt="MyCat原理"><br>当Mycat收到一个SQL时，会<strong>先解析这个SQL，查找涉及到的表，然后看此表的定义，如果有分片规则，则获取到SQL里分片字段的值，并匹配分片函数，得到该SQL对应的分片列表，然后将SQL发往这些分片去执行，最后收集和处理所有分片返回的结果数据，并输出到客户端</strong>。以select * from Orders where prov=?语句为例，查到prov=wuhan，按照分片函数，wuhan返回dn1，于是SQL就发给了MySQL1，去取DB1上的查询结果，并返回给用户。<br>如果上述SQL改为select * from Orders where prov in (‘wuhan’,‘beijing’)，那么，SQL就会发给MySQL1与MySQL2去执行，然后结果集合并后输出给用户。但通常业务中我们的SQL会有Order By 以及Limit翻页语法，此时就涉及到结果集在Mycat端的二次处理，这部分的代码也比较复杂，而最复杂的则属两个表的Join问题，为此，Mycat提出了创新性的ER分片、全局表、HBT（Human Brain Tech)人工智能的Catlet、以及结合Storm/Spark引擎等十八般武艺的解决办法，从而成为目前业界最强大的方案，这就是开源的力量！</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Mycat发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景：</p>
<ul>
<li>单纯的读写分离，此时配置最为简单，支持读写分离，主从切换；</li>
<li>分表分库，对于超过1000万的表进行分片，最大支持1000亿的单表分片；</li>
<li>多租户应用，每个应用一个库，但应用程序只连接Mycat，从而不改造程序本身，实现多租户化；</li>
<li>报表系统，借助于Mycat的分表能力，处理大规模报表的统计；</li>
<li>替代Hbase，分析大数据；</li>
<li>作为海量数据实时查询的一种简单有效方案，比如100亿条频繁查询的记录需要在3秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时Mycat可能是最简单有效的选择。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>对数据的处理一般分为两种 数据量大和实时性高</li>
<li>nosql无法取代关系型数据库</li>
<li>数据库切分有两种 <blockquote>
<p>垂直切分：将数据库和表放到不同的服务<br>水平切分：将一个表中的数据放到不同节点上</p>
</blockquote>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>MyCat</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat入门-目录</title>
    <url>/2021/09/24/mycat%E5%85%A5%E9%97%A8-2/</url>
    <content><![CDATA[<h2 id="MyCat目录结构"><a href="#MyCat目录结构" class="headerlink" title="MyCat目录结构"></a>MyCat目录结构</h2><p><img src="image004.png"><br>目录解释如下：</p>
<p><strong>bin 程序目录</strong>，存放了window版本和linux版本，除了提供封装成服务的版本之外，也提供了nowrap的shell脚本命令，方便选择和修改，进入到bin目录：<br>Linux下运行：./mycat console,首先要chmod +x *<br>注：mycat支持的命令{ console | start | stop | restart | status | dump }</p>
<p><strong>conf目录下存放配置文件</strong>，server.xml是Mycat服务器参数调整和用户授权的配置文件，schema.xml是逻辑库定义和表以及分片定义的配置文件，rule.xml是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改，需要重启Mycat或者通过9066端口reload.</p>
<p><strong>lib目录下主要存放mycat依赖的一些jar文件.</strong></p>
<p><strong>日志存放在logs/mycat.log中</strong>，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要，可以调整输出级别为debug，debug级别下，会输出更多的信息，方便排查问题.<br>注意：Linux下部署安装MySQL，默认不忽略表名大小写，需要手动到/etc/my.cnf 下配置 lower_case_table_names=1 使Linux环境下MySQL忽略表名大小写，否则使用MyCAT的时候会提示找不到表的错误！</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><a href="http://www.mycat.org.cn/document/mycat-definitive-guide.pdf">配置文件参数参考</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>MyCat</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket-简介</title>
    <url>/2021/09/13/webSocket/</url>
    <content><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><h3 id="计算机网络层次划分"><a href="#计算机网络层次划分" class="headerlink" title="计算机网络层次划分"></a>计算机网络层次划分</h3><p>国际标准化住址(ISO)在1979年提出OSI七层模型，常见的网络层次划分还有TCP/IP四层协议和TCP/IP五层协议，对应关系如下<br><img src="%E9%9A%8F%E7%AC%94-%E6%95%B0%E6%8D%AE%E5%BA%93/img.png"></p>
<h4 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h4><p>TCP/IP协议是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都有自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我以OSI七层模型为例从上向下进行一一介绍 </p>
<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>应用层是操作系统或网络应用程序提供访问网络服务的接口。</p>
<h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h5><p>表示层对上层数据或信息进行变换，保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h5><p>会话层管理主机之间的会话进程，负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<p>会话层、表示层、应用层重点：</p>
<p>数据传输基本单位为报文<br>包含的主要协议：FTP（文件传输协议）、Telnet（远程登陆协议）、DNS（域名解析协议）、SMTP（邮件传送协议）、POP3协议（邮局协议）、HTTP协议（Hyper Text Transfer Protocol） </p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>第一个端到端（主机到主机）的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。<br>传输层的任务是根据通信子网的特性，利用最佳的网络资源，为两个端系统的会话层之间提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p>
<p>有关传输层的重点：</p>
<p>包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）<br>重要设备：网关</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>网络层的目的是实现两端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。</p>
<p>它提供的服务使传输层不需要了解网络中的数据传输和交换技术。用少量的词来记忆网络层，那就是“路径选择，路由及逻辑寻址”。</p>
<p>网络层涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP</p>
<h3 id="半双工-全双工-单工"><a href="#半双工-全双工-单工" class="headerlink" title="半双工 全双工 单工"></a>半双工 全双工 单工</h3><h4 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h4><p>双向同时传递消息</p>
<h4 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h4><p>双向不同时传递消息</p>
<h4 id="单向"><a href="#单向" class="headerlink" title="单向"></a>单向</h4><p>单向传递消息</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>websocket是一个基于应用层的网络协议，建于tcp协议之上。相当于在http连接之后，将服务器请求升级为websocket协议。<br>和Http协议对比，最大的区别就是服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>webSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>docker || docker-compose-安装</title>
    <url>/2021/09/03/windows%E5%AE%89%E8%A3%85Hyper-V+ubuntu/</url>
    <content><![CDATA[<h2 id="Windows10家庭版安装ubuntu"><a href="#Windows10家庭版安装ubuntu" class="headerlink" title="Windows10家庭版安装ubuntu"></a>Windows10家庭版安装ubuntu</h2><h3 id="安装Hyper-V"><a href="#安装Hyper-V" class="headerlink" title="安装Hyper-V"></a>安装Hyper-V</h3><p><a href="https://blog.csdn.net/yuyuking/article/details/103890195">参考博文</a><br>把下面代码保存为.bat文件，用管理员运行，重启之后，就可以在win+S 中搜索到Hyper-V</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hyper-v.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure>

<h3 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h3><p><a href="https://zhuanlan.zhihu.com/p/128640396">参考博文</a><br>基本就是按照操作一步一步点下来。<br>MSDN好像没有ubuntu的镜像了，可以点击<a href="http://mirrors.163.com/ubuntu-releases">网易开源镜像站</a>下载<br>启动之后，会遇到这样的问题，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hyper-V™</span><br><span class="line">Uirtual Machine Boot Su_ary</span><br><span class="line"></span><br><span class="line">1.SCSI Disk (0,0)No UEFI-compatible file system uas found.</span><br><span class="line"></span><br><span class="line">2.Network Adapter (OO155DO6E40O) DHCP failed.</span><br><span class="line"></span><br><span class="line">3.SCSI DUD (0,1)No UEFI-compatible file system uas found.</span><br><span class="line"></span><br><span class="line">No operating system was loaded. Press a Key to retry the boot sequence...</span><br><span class="line">Note： Configuration changes nay require the virtual Machine to be reset.</span><br></pre></td></tr></table></figure>

<p>把虚拟机启动时启用安全启动的勾去掉。<a href="https://tieba.baidu.com/p/5587795237?red_tag=0742118433">解决方法</a></p>
<h2 id="linux安装docker"><a href="#linux安装docker" class="headerlink" title="linux安装docker"></a>linux安装docker</h2><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><p>安装方法<a href="https://www.cnblogs.com/kingsonfu/p/11576797.html">参考博文</a><br>使用的yum源安装</p>
<ol>
<li>查看是否已安装docker<br><code>yum list installed | grep docker</code></li>
<li>安装docker<br><code>yum -y install docker</code></li>
<li>启动docker<br><code>systemctl start docker</code></li>
<li>查看docker状态<br><code> systemctl status docker</code><br>如果出现下面代表安装成功<br><img src="%E9%9A%8F%E7%AC%94-%E6%95%B0%E6%8D%AE%E5%BA%93/img.png" alt="安装成功"></li>
<li>可以将docker设置为开机自启动<br><code>systemctl enable docker;</code><h3 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h3></li>
<li>下载docker压缩包<br><a href="https://download.docker.com/linux/static/stable/x86_64/">下载地址</a><br>笔者下载的是docker-18.06.3-ce.tgz</li>
<li>运行脚本<br><code>./install_docker.sh docker-18.06.3-ce.tgz</code><br>脚本代码如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">usage()&#123;</span><br><span class="line">  echo &quot;使用方法: $0 FILE_NAME_DOCKER_CE_TAR_GZ&quot;</span><br><span class="line">  echo &quot;             $0 docker-18.06.3-ce.tgz&quot;</span><br><span class="line">  echo &quot;Get docker-ce binary from: https://download.docker.com/linux/static/stable/x86_64/&quot;</span><br><span class="line">  echo &quot;eg: wget https://download.docker.com/linux/static/stable/x86_64/docker-18.06.3-ce.tgz&quot;</span><br><span class="line">  echo &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">SYSTEMDDIR=/usr/lib/systemd/system</span><br><span class="line">SERVICEFILE=docker.service</span><br><span class="line">DOCKERDIR=/usr/bin</span><br><span class="line">DOCKERBIN=docker</span><br><span class="line">SERVICENAME=docker</span><br><span class="line"></span><br><span class="line">if [ $# -ne 1 ]; then</span><br><span class="line">  usage</span><br><span class="line">  exit 1</span><br><span class="line">else</span><br><span class="line">  FILETARGZ=&quot;$1&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -f $&#123;FILETARGZ&#125; ]; then</span><br><span class="line">  echo &quot;Docker binary tgz files does not exist, please check it&quot;</span><br><span class="line">  echo &quot;Get docker-ce binary from: https://download.docker.com/linux/static/stable/x86_64/&quot;</span><br><span class="line">  echo &quot;eg: wget https://download.docker.com/linux/static/stable/x86_64/docker-18.06.3-ce.tgz&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;##unzip : tar xvpf $&#123;FILETARGZ&#125;&quot;</span><br><span class="line">tar xvpf $&#123;FILETARGZ&#125;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo &quot;##binary : $&#123;DOCKERBIN&#125; copy to $&#123;DOCKERDIR&#125;&quot;</span><br><span class="line">cp -p $&#123;DOCKERBIN&#125;/* $&#123;DOCKERDIR&#125; &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">which $&#123;DOCKERBIN&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;##systemd service: $&#123;SERVICEFILE&#125;&quot;</span><br><span class="line">echo &quot;##docker.service: create docker systemd file&quot;</span><br><span class="line">cat &gt;$&#123;SYSTEMDDIR&#125;/$&#123;SERVICEFILE&#125; &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=http://docs.docker.com</span><br><span class="line">After=network.target docker.socket</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=-/run/flannel/docker</span><br><span class="line">WorkingDirectory=/usr/local/bin</span><br><span class="line">ExecStart=/usr/bin/dockerd \</span><br><span class="line">                -H tcp://0.0.0.0:4243 \</span><br><span class="line">                -H unix:///var/run/docker.sock \</span><br><span class="line">                --selinux-enabled=false \</span><br><span class="line">                --log-opt max-size=1g</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line"><span class="meta">#</span><span class="bash"> Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the kernel. We recommend using cgroups to <span class="keyword">do</span> container-local accounting.</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment TasksMax <span class="keyword">if</span> your systemd version supports it.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Only systemd 226 and above support this version.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">TasksMax=infinity</span></span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line">Delegate=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span> only the docker process, not all processes <span class="keyword">in</span> the cgroup</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">echo &quot;##Service status: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl status $&#123;SERVICENAME&#125;</span><br><span class="line">echo &quot;##Service restart: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl restart $&#123;SERVICENAME&#125;</span><br><span class="line">echo &quot;##Service status: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl status $&#123;SERVICENAME&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;##Service enabled: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl enable $&#123;SERVICENAME&#125;</span><br><span class="line">cat &gt;/etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">swapoff -a</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">sysctl --system</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br><span class="line"></span><br><span class="line">echo &quot;## docker version&quot;</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
如果有坏的解释器报错 则<code>sed -i &#39;s/\r$//&#39;  install_docker.sh</code><br>如果有权限问题可 可<code>chmod 777 /data/install_docker.sh</code><h2 id="docker换源"><a href="#docker换源" class="headerlink" title="docker换源"></a>docker换源</h2><a href="https://www.cnblogs.com/wpwen/p/12652665.html">docker换源</a><br>换源的方法是编辑/etc/docker/daemon.json（如果不存在则创建）:<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span>:[</span><br><span class="line">         <span class="string">&quot;http://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">         <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">         <span class="string">&quot;http://registry.docker-cn.com&quot;</span></span><br><span class="line">    ] ,</span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span>:[</span><br><span class="line">       <span class="string">&quot;docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">         <span class="string">&quot;registry.docker-cn.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议使用<a href="https://docs.docker.com/engine/install/centos/">官网安装</a></p>
</blockquote>
<h2 id="docker-安装php-nginx-mysql"><a href="#docker-安装php-nginx-mysql" class="headerlink" title="docker 安装php+nginx+mysql"></a>docker 安装php+nginx+mysql</h2><h3 id="获取镜像image"><a href="#获取镜像image" class="headerlink" title="获取镜像image"></a>获取镜像image</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7      # 拉取 mysql 5.7</span><br><span class="line">docker nginx               # 拉取 nginx </span><br><span class="line">docker pull php:5.6-fpm    # 拉取 php </span><br></pre></td></tr></table></figure>
docker images              # 查看安装镜像</li>
</ol>
<h3 id="普通运行"><a href="#普通运行" class="headerlink" title="普通运行"></a>普通运行</h3><p><code>docker run -p 对外暴露的端口:容器内的端口 --name 容器名 -e 配置信息=内容 -v 主机目录:容器目录 -d 镜像名</code><br>使用 <code>docker ps</code> || <code>docker ps -a</code> 查看运行||全部容器</p>
<h3 id="docker-compose运行"><a href="#docker-compose运行" class="headerlink" title="docker-compose运行"></a>docker-compose运行</h3><p>文件模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2.0&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    restart: always</span><br><span class="line">    image: nginx:1.11.6-alpine</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">      - 80:80</span><br><span class="line">      - 443:443</span><br><span class="line">    volumes:</span><br><span class="line">      - ./conf.d:/etc/nginx/conf.d</span><br><span class="line">      - ./log:/var/log/nginx</span><br><span class="line">      - ./www:/var/www</span><br><span class="line">      - /etc/letsencrypt:/etc/letsencrypt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong><br><strong>version</strong>：版本号</p>
<p><strong>service</strong>：就是要定义的docker容器</p>
<p><strong>nginx</strong>:容器的名称</p>
<p><strong>restart</strong>：设置为always，表明此容器应该在停止的情况下总是重启，比如，服务器启动时，这个容器就跟着启动，不用手动启动，服务器启动之后，进入到docker-compose.yml文件路径下，执行docker-compose ps可以看到，该容器正在运行。</p>
<p><strong>image</strong>：这个是需要依赖的容器，也就是nginx软件，可以到docker官方镜像上找到最新版的镜像。</p>
<p><strong>ports</strong>：端口映射。比如： - 8080:80，表示容器内运行着的端口是80，把端口暴露给8080端口，从外面访问的是8080端口，就能自动映射到80端口上。</p>
<p><strong>volumes</strong>:文件映射。表示数据、配置文件等存放的位置。（- . 这个表示docker-compose.yml当前目录位置开始创建这个文件</p>
<h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><p>如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因：</p>
<ul>
<li>防火墙拦截<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开放端口：</span><br><span class="line">$ systemctl status firewalld</span><br><span class="line">$ firewall-cmd  --zone=public --add-port=3306/tcp -permanent</span><br><span class="line">$ firewall-cmd  --reload</span><br><span class="line"># 关闭防火墙：</span><br><span class="line">$ sudo systemctl stop firewalld</span><br></pre></td></tr></table></figure></li>
<li>需要在docker本地客户端设置远程访问账号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker exec -it mysql bash</span><br><span class="line">$ mysql -uroot -p123456</span><br><span class="line">mysql&gt; grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;</span><br></pre></td></tr></table></figure>
原理：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改）</span><br><span class="line"></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; select host,user,password from user;</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| host                    | user      | password                                                                 |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| localhost              | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |</span><br><span class="line">| 192.168.1.1            | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; grant all privileges  on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select host,user,password from user;</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| host                    | user      | password                                                                 |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">| localhost              | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |</span><br><span class="line">| 192.168.1.1            | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |</span><br><span class="line">| %                       | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |</span><br><span class="line">+--------------+------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><h3 id="在线安装-1"><a href="#在线安装-1" class="headerlink" title="在线安装"></a>在线安装</h3><del>第一步下载：</del><br><del><code>curl -L https://get.daocloud.io/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` &gt;  /usr/local/bin/docker-compose</code></del><br><del>第二步赋权：</del><br><del><code>chmod a+x /usr/local/bin/docker-compose</code></del><br><del>第三步查看版本：</del><br><del><code>docker-compose --version</code></del><blockquote>
<p>上面的方法在部署之后，使用docker-compose部署会出现端口占用的错误，且物理机，虚拟机端口并没有被占用<br>在一段时间的问题定位之后，发现是安装的docker-compose有问题，所以建议使官网安装<a href="https://docs.docker.com/compose/install/">安装地址</a><br>步骤和上方基本相同，第一步下载的地址发生了改变</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
<h3 id="离线安装-1"><a href="#离线安装-1" class="headerlink" title="离线安装"></a>离线安装</h3><p>操作同上</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>安装netstat<br><code>yum -y install net-tools </code><br><a href="https://hub.docker.com/">docker-hub地址</a><br><a href="https://docs.docker.com/">docker-文档地址</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>虚拟机</tag>
        <tag>Hyper-V</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>基于STOMP协议整合WebSocket</title>
    <url>/2021/09/14/%E5%9F%BA%E4%BA%8ESTOMP%E5%8D%8F%E8%AE%AE%E6%95%B4%E5%90%88WebSocket/</url>
    <content><![CDATA[<h2 id="基于STOMP协议整合WebSocket"><a href="#基于STOMP协议整合WebSocket" class="headerlink" title="基于STOMP协议整合WebSocket"></a>基于STOMP协议整合WebSocket</h2><p>模拟过程-客户端和服务端长连接，客户端发送消息，服务端对消息处理返回给全部客户端<br><a href="https://zhuanlan.zhihu.com/p/58311007">原文地址</a><br>核心原理：</p>
<ol>
<li>实现WebSocketMessageBrokerConfigurer接口，覆盖registerStompEndpoints方法，并注册一个节点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册一个名为 /endpointNasus 的 Stomp 节点(endpoint),并指定使用 SockJS 协议。</span></span><br><span class="line">    registry.addEndpoint(<span class="string">&quot;/endpointNasus&quot;</span>).withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端连接之后，向连接指定路由发送请求,服务端接收请求 发送到注解SendTo指定位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 连接 SockJs 的 endpoint 名称为 &quot;/endpointNasus&quot;</span></span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">&#x27;/endpointNasus&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用 STOMP 子协议的 WebSocket 客户端</span></span><br><span class="line">    stompClient = Stomp.over(socket);</span><br><span class="line">    stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span><br><span class="line">        setConnected(<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">        <span class="comment">// 通过 stompClient.subscribe 订阅 /nasus/getResponse 目标发送的信息，对应控制器的 SendTo 定义</span></span><br><span class="line">        stompClient.subscribe(<span class="string">&#x27;/nasus/getResponse&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">respnose</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 展示返回的信息，只要订阅了 /nasus/getResponse 目标，都可以接收到服务端返回的信息</span></span><br><span class="line">        showResponse(<span class="built_in">JSON</span>.parse(respnose.body).responseMessage);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向服务端发送消息</span></span><br><span class="line">    <span class="keyword">var</span> name = $(<span class="string">&#x27;#name&#x27;</span>).val();</span><br><span class="line">    <span class="comment">// 通过 stompClient.send 向 /hello （服务端）发送信息，对应控制器 @MessageMapping 中的定义</span></span><br><span class="line">    stompClient.send(<span class="string">&quot;/hello&quot;</span>, &#123;&#125;, <span class="built_in">JSON</span>.stringify(&#123; <span class="string">&#x27;name&#x27;</span>: name &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MessageMapping(&quot;/hello&quot;)</span> <span class="comment">// @MessageMapping 和 @RequestMapping 功能类似，浏览器向服务器发起请求时，映射到该地址。</span></span><br><span class="line"><span class="meta">@SendTo(&quot;/nasus/getResponse&quot;)</span> <span class="comment">//如果服务器接受到了消息，就会对订阅了 @SendTo 括号中的地址的浏览器发送消息。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server2ClientMessage <span class="title">say</span><span class="params">(Client2ServerMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Server2ClientMessage(<span class="string">&quot;Hello,&quot;</span> + message.getName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端绑定SendTo位置的会收到信息<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 广播式配置名为 /nasus 消息代理 , 这个消息代理必须和 controller 中的 @SendTo 配置的地址前缀一样或者全匹配</span></span><br><span class="line">    <span class="comment">// 点对点增加一个 /queue 消息代理</span></span><br><span class="line">    registry.enableSimpleBroker(<span class="string">&quot;/queue&quot;</span>,<span class="string">&quot;/nasus/getResponse&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function connect() &#123;</span><br><span class="line">    // 连接 SockJs 的 endpoint 名称为 &quot;/endpointNasus&quot;</span><br><span class="line">    var socket = new SockJS(&#x27;/endpointNasus&#x27;);</span><br><span class="line">    // 使用 STOMP 子协议的 WebSocket 客户端</span><br><span class="line">    stompClient = Stomp.over(socket);</span><br><span class="line">    stompClient.connect(&#123;&#125;, function(frame) &#123;</span><br><span class="line">        setConnected(true);</span><br><span class="line">        console.log(&#x27;Connected: &#x27; + frame);</span><br><span class="line">        // 通过 stompClient.subscribe 订阅 /nasus/getResponse 目标发送的信息，对应控制器的 SendTo 定义</span><br><span class="line">        stompClient.subscribe(&#x27;/nasus/getResponse&#x27;, function(respnose)&#123;</span><br><span class="line">        // 展示返回的信息，只要订阅了 /nasus/getResponse 目标，都可以接收到服务端返回的信息</span><br><span class="line">        showResponse(JSON.parse(respnose.body).responseMessage);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
依赖：<br>前端：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script th:src=<span class="string">&quot;@&#123;sockjs.min.js&#125;&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;stomp.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;jquery.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- web 启动类 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- WebSocket 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>指令仓库</title>
    <url>/2021/09/23/%E6%8C%87%E4%BB%A4%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>随笔-mysql</title>
    <url>/2021/09/30/%E9%9A%8F%E7%AC%94-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -h xxx.xxx.xxx.xxx -P 3306 -u root -p nethos_med --default-character-set=utf8 -R --disable-keys &gt; </span><br><span class="line">C:\nethos_med.sql</span><br></pre></td></tr></table></figure>
<p>-R 导出存储过程以及自定义函数<br><a href="https://www.cnblogs.com/qq78292959/p/3637135.html">更多参数说明</a></p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h xxx.xxx.xxx.xxx -P3306 -uroot -p nethos_core  --default-character-set=utf8  &lt; /home/nethos_core.sql</span><br></pre></td></tr></table></figure>
<p>-f 遇到错误后继续</p>
<h3 id="查看存储过程和函数"><a href="#查看存储过程和函数" class="headerlink" title="查看存储过程和函数"></a>查看存储过程和函数</h3><p>查询数据库中的存储过程和函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select `name` from mysql.proc where db = &#x27;xx&#x27; and `type` = &#x27;PROCEDURE&#x27;   //存储过程</span><br><span class="line">select `name` from mysql.proc where db = &#x27;xx&#x27; and `type` = &#x27;FUNCTION&#x27;   //函数</span><br><span class="line"></span><br><span class="line">show procedure status; //存储过程</span><br><span class="line">show function status;     //函数</span><br></pre></td></tr></table></figure>
<p>查看视图和触发器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * from information_schema.VIEWS   //视图</span><br><span class="line">SELECT * from information_schema.TABLES   //表</span><br><span class="line"></span><br><span class="line">SHOW TRIGGERS [FROM db_name] [LIKE expr]</span><br><span class="line">SELECT * FROM triggers T WHERE trigger_name=&quot;mytrigger&quot; \G</span><br></pre></td></tr></table></figure>
<h3 id="mysql复制表结构和内容到另外一张表"><a href="#mysql复制表结构和内容到另外一张表" class="headerlink" title="mysql复制表结构和内容到另外一张表"></a>mysql复制表结构和内容到另外一张表</h3><p><strong>复制表结构和数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create table 新表</span><br><span class="line">select * from 旧表  </span><br></pre></td></tr></table></figure>
<p><strong>只复制表结构</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create table 新表</span><br><span class="line">select * from 旧表 where 1=2</span><br></pre></td></tr></table></figure>
<p><strong>只复制表结构</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create table 新表 like 旧表</span><br></pre></td></tr></table></figure>
<p><strong>复制旧表的数据到新表（假设两个表结构一样）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insert into 新表</span><br><span class="line">select * from 旧表  </span><br></pre></td></tr></table></figure>
<p><strong>复制旧表的数据到新表（假设两个表结构不一样）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insert into 新表(字段1,字段2,…….)</span><br><span class="line">select 字段1,字段2,…… from 旧表</span><br></pre></td></tr></table></figure>
<h3 id="查询字段有那些值"><a href="#查询字段有那些值" class="headerlink" title="查询字段有那些值"></a>查询字段有那些值</h3><p><code>select distinct first_name from table_user;</code></p>
<h3 id="添加order-by-null"><a href="#添加order-by-null" class="headerlink" title="添加order by null"></a>添加order by null</h3><p>作用: 在使用group by的时候会默认排序,order by null 会取消排序</p>
<h3 id="sql-将字段复制到另一个字段"><a href="#sql-将字段复制到另一个字段" class="headerlink" title="sql 将字段复制到另一个字段"></a>sql 将字段复制到另一个字段</h3><p><code>update table  set  test2  =  test1</code></p>
<h2 id="数据库报错"><a href="#数据库报错" class="headerlink" title="数据库报错"></a>数据库报错</h2><h3 id="mysql-1055"><a href="#mysql-1055" class="headerlink" title="mysql 1055"></a>mysql 1055</h3><p>mysql版本导致默认配置修改,ONLY_FULL_GROUP_BY：对于GROUP BY聚合操作，若select中的列没有在group by中出现，那么这句SQL是不合法的。<br>修改mysql配置(windows安装路径,Linux/etc/mysql)<br><code>sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</code><br>sql_mode常用值</p>
<ul>
<li>ONLY_FULL_GROUP_BY<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中。</span><br><span class="line">在严格模式下，不要让GROUP BY部分中的查询指向未选择的列，否则报错。</span><br></pre></td></tr></table></figure></li>
<li>NO_AUTO_VALUE_ON_ZERO<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</span><br></pre></td></tr></table></figure></li>
<li>STRICT_TRANS_TABLES<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</span><br></pre></td></tr></table></figure></li>
<li>NO_ZERO_IN_DATE<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在严格模式下，不允许日期和月份为零</span><br></pre></td></tr></table></figure></li>
<li>NO_ZERO_DATE<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</span><br></pre></td></tr></table></figure></li>
<li>ERROR_FOR_DIVISION_BY_ZERO<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</span><br></pre></td></tr></table></figure></li>
<li>NO_AUTO_CREATE_USER<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">禁止GRANT创建密码为空的用户</span><br></pre></td></tr></table></figure></li>
<li>NO_ENGINE_SUBSTITUTION<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</span><br></pre></td></tr></table></figure></li>
<li>PIPES_AS_CONCAT<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将&quot;||&quot;视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</span><br></pre></td></tr></table></figure></li>
<li>ANSI_QUOTES<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符；</span><br><span class="line">ORACLE的sql_mode设置等同：PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER.</span><br></pre></td></tr></table></figure>
<h3 id="MySQL-server-has-gone-away"><a href="#MySQL-server-has-gone-away" class="headerlink" title="MySQL server has gone away"></a>MySQL server has gone away</h3>问题再现：mysql导入大文件报错<br>出现原因：Mysql配置项max_allowed_packet过小<br>问题解析：max_allowed_packet项控制mysql服务端接收的包的大小<br>问题解决：<br>查看max_allowed_packet<br><code>show global variables like &#39;max_allowed_packet&#39;;</code><br><img src="img.png" alt="max_allowed_packet默认值.png"><br>将默认值修改为150M<br><code>set global max_allowed_packet=157286400;</code><br>注意：修改旨在当前设置中生效，重启mysql后恢复默认值，永久生效可以通过my.cnf中添加<code>max_allowed_packet=150M</code>即可<h2 id="mysql解析过程"><a href="#mysql解析过程" class="headerlink" title="mysql解析过程"></a>mysql解析过程</h2><a href="https://zhuanlan.zhihu.com/p/354255965">参考1</a><br><a href="https://www.cnblogs.com/fanguangdexiaoyuer/p/10268570.html">参考2</a><br><a href="https://www.php.cn/mysql-tutorials-483021.html">参考3</a><blockquote>
<p>最宏观的来看，一个系统分为JAVA端和MYSQL端<br>看作<code>JAVA-&gt;MYSQL</code></p>
<p>但连接数据库的操作往往都是固定的，于是有人封装这些代码，称之为数据库驱动<br>这时<code>JAVA业务-&gt;MYSQL驱动-&gt;MYSQL</code></p>
<p>在向MYSQL发送请求的时候，如果每次都新建，删除连接，会造成性能的浪费和下降，通常会提供固定数量连接的线程，数据库连接池<br>现在<code>JAVA业务-&gt;数据库连接池-&gt;MYSQL驱动-&gt;MYSQL</code></p>
<p>同理，MYSQL接收发送请求的线程也是一个连接池<br><code>JAVA业务-&gt;数据库发送池-&gt;MYSQL驱动-&gt;数据库接收池-&gt;MYSQL</code></p>
<p>在进入MYSQL服务之后，如果查询缓存是打开的(默认关闭)，mysql会优先检查查询是否命中缓存，通过一个对大小写敏感的哈希查找实现</p>
<ul>
<li>只要有一个表的更新，缓存清空</li>
<li>SQL上任何字符不同，例如空格，注释，缓存都不会命中<br><code>JAVA业务-&gt;数据库发送池-&gt;MYSQL驱动-&gt;数据库接收池-&gt;查询缓存-&gt;</code></li>
</ul>
<p>之后MYSQL对传递过来的SQL语句进行解析，和检查<br>词法解析：将完整的SQL语句打散成单词 语法分析：引号有没有闭合 语义分析：表名和字段是否存在<br><code>JAVA业务-&gt;数据库发送池-&gt;MYSQL驱动-&gt;数据库接收池-&gt;查询缓存-&gt;解析器-&gt;</code></p>
<p>解析过后，会由优化器将解析之后的语法树转化成执行计划，查询优化器找到最好的执行计划，通过存储引擎执行并返回结果<br>使用EXPlain可以看到执行计划的信息<br><code>JAVA业务-&gt;数据库发送池-&gt;MYSQL驱动-&gt;数据库接收池-&gt;查询缓存-&gt;解析器-&gt;查询优化-&gt;存储引擎(执行器)</code></p>
</blockquote>
</li>
</ul>
<h2 id="MyCat-Limit操作"><a href="#MyCat-Limit操作" class="headerlink" title="MyCat Limit操作"></a>MyCat Limit操作</h2><ul>
<li>无offset 无order by<br>取决于哪个节点先返回数据(同一个SQL会有不同的结果)</li>
<li>无offset 有order by<br>对每个节点返回的数据进行最小堆计算，计算所有结果的最小记录返回给应用</li>
<li>有offset，有order by<br>limit m,n 会被改写为limit 0,m+n 对性能的消耗大幅度增加</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-运维(Windows||Linux)</title>
    <url>/2021/09/26/%E9%9A%8F%E7%AC%94_windows_linux/</url>
    <content><![CDATA[<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><h3 id="windows查看端口占用"><a href="#windows查看端口占用" class="headerlink" title="windows查看端口占用"></a>windows查看端口占用</h3><ol>
<li>cmd</li>
<li>netstat -ano | findstr 端口号 记下pid</li>
<li>任务管理器 pid查找进程</li>
</ol>
<h3 id="查看域名对应ip"><a href="#查看域名对应ip" class="headerlink" title="查看域名对应ip"></a>查看域名对应ip</h3><p><code>ping</code></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="目录作用"><a href="#目录作用" class="headerlink" title="目录作用"></a>目录作用</h3><p><a href="https://www.cnblogs.com/amboyna/archive/2008/02/16/1070474.html">参考博文</a></p>
<h3 id="ls-只列出部分目录或是文件"><a href="#ls-只列出部分目录或是文件" class="headerlink" title="ls 只列出部分目录或是文件"></a>ls 只列出部分目录或是文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.只列出前N个目录:  ls | head -n</span><br><span class="line">2.只列出image1,image2目录 :  ls -d image[1-2] 或 ls -d image1 iamge2</span><br><span class="line">3. 列出所有image开头的目录; ls -d image*</span><br></pre></td></tr></table></figure>
<h3 id="修改文件权限等"><a href="#修改文件权限等" class="headerlink" title="修改文件权限等"></a>修改文件权限等</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R 账号名称  文件/目录                                         # 修改文件所有者</span><br><span class="line">chmod 755 /etc/init.d/delete.sh                                   # 修改权限</span><br><span class="line">chgrp  组群  文件名/目录                                             # 修改文件所属组群</span><br></pre></td></tr></table></figure>

<h3 id="定时删除缓存的脚本"><a href="#定时删除缓存的脚本" class="headerlink" title="定时删除缓存的脚本"></a>定时删除缓存的脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">dir=/data/docker/pubback2_cywx/nginx/html/sns/Application/Runtime #需要清空的目录名称</span><br><span class="line">files=`ls $&#123;dir&#125;`</span><br><span class="line">for file in $files</span><br><span class="line">do</span><br><span class="line">if [ -e $&#123;dir&#125;/$&#123;file&#125; ];then</span><br><span class="line">rm -rf $&#123;dir&#125;/$&#123;file&#125;</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 /etc/init.d/delete.sh #给脚本755权限</span><br><span class="line">crontab –e #添加定时任务</span><br><span class="line">0 3 * * * /etc/init.d/delete.sh</span><br></pre></td></tr></table></figure>
<p>分 时 日 月 周 命令<br>第1列<em>号表示分钟1-59 每分钟用</em>或者 <em>/1表示<br>第2列</em>号表示小时0-23小时（0表示0点）<br>第3列<em>号表示日期1-31日<br>第4列</em>号表示月份1-12月<br>第5列*号表示每周，0-6（0表示星期天）<br>第6列是要运行的命令</p>
<p>例如每周3的晚上23:30运行该脚本，可以这样写：<br>30 23 * * 3 /etc/init.d/delete.sh</p>
<h3 id="磁盘满了清理"><a href="#磁盘满了清理" class="headerlink" title="磁盘满了清理"></a>磁盘满了清理</h3><p><a href="https://blog.csdn.net/gnail_oug/article/details/70217446">df指令参数参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看磁盘信息 -h转化单位</span></span><br><span class="line">df -lh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定位最大文件</span></span><br><span class="line">du -h --max-depth=1 # 查看当前目录下一级子文件和子目录占用的磁盘容量</span><br><span class="line">du -sc * | sort -rn # 排序</span><br><span class="line">du -sb /usr/share/nginx/html/sns/Application/Runtime/* | sort -rn</span><br></pre></td></tr></table></figure>
<h3 id="防火墙操作"><a href="#防火墙操作" class="headerlink" title="防火墙操作"></a>防火墙操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld.service   #查看状态</span><br><span class="line">systemctl stop firewalld.service     #停止</span><br><span class="line">systemctl disable firewalld.service  #禁止</span><br><span class="line">systemctl restart firewalld.service  #重启</span><br><span class="line">systemctl start firewalld.service    #启动</span><br></pre></td></tr></table></figure>
<h3 id="查看端口使用"><a href="#查看端口使用" class="headerlink" title="查看端口使用"></a>查看端口使用</h3><ol>
<li><code>netstat  -anp  |grep   端口号</code> </li>
<li><code>netstat   -nultp</code> 查看当前已使用的端口</li>
</ol>
<h3 id="添加用户到docker用户组"><a href="#添加用户到docker用户组" class="headerlink" title="添加用户到docker用户组"></a>添加用户到docker用户组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加用户(默认会在/home/下创建你的文件夹)</span></span><br><span class="line">useradd htr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户密码</span></span><br><span class="line">passwd htr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker用户组，一般已存在，不需要执行</span></span><br><span class="line">cat /etc/group</span><br><span class="line">sudo groupadd docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加用户到工作组</span></span><br><span class="line">usermod -a -G docker htr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试是否可以使用docker(需要重新登陆用户)</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<h3 id="显示当前路径"><a href="#显示当前路径" class="headerlink" title="显示当前路径"></a>显示当前路径</h3><p><code>pwd</code></p>
<h3 id="显示当前用户"><a href="#显示当前用户" class="headerlink" title="显示当前用户"></a>显示当前用户</h3><p><code>w</code></p>
<h3 id="Linux-ls-l-文件颜色和意义"><a href="#Linux-ls-l-文件颜色和意义" class="headerlink" title="Linux ls -l 文件颜色和意义"></a>Linux ls -l 文件颜色和意义</h3><p>白色：表示普通文件<br>蓝色：表示目录<br>绿色：表示可执行文件<br>红色：表示压缩文件<br>浅蓝色：链接文件<br>红色闪烁：表示链接的文件有问题<br>黄色：表示设备文件<br>灰色：表示其他文件</p>
<h3 id="bin-bash-M-坏的解释器-没有那个文件或目录"><a href="#bin-bash-M-坏的解释器-没有那个文件或目录" class="headerlink" title="/bin/bash^M: 坏的解释器: 没有那个文件或目录"></a>/bin/bash^M: 坏的解释器: 没有那个文件或目录</h3><p>脚本文件在windows下编辑过，windows下每一行的结尾是\n\r，而在linux下文件的结尾是\n，那么你在windows下编辑过的文件在linux下打开看的时候每一行的结尾就会多出来一个字符\r,<br>用cat -A filename时你可以看到这个\r字符被显示为^M<br>使用<code>sed -i &#39;s/\r$//&#39; filename</code>删掉就可以</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Linux操作好习惯"><a href="#Linux操作好习惯" class="headerlink" title="Linux操作好习惯"></a>Linux操作好习惯</h3><ol>
<li>避免用root用户登陆</li>
<li>命名文件只使用字母，数字，连接符(-)和下划线(_)</li>
<li>对目录操作使用绝对路径</li>
<li>不用的shell及时关掉，避免在错误的服务器上进行操作</li>
<li>执行脚本时看好变量</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-Java代码规范</title>
    <url>/2021/11/18/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis逆向工程</title>
    <url>/2021/11/18/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h3><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!-- mybatis --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- jdbc驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.18&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mybatis逆向工程 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.3.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="引入逆向工程的配置文件generatorConfig-xml并配置"><a href="#引入逆向工程的配置文件generatorConfig-xml并配置" class="headerlink" title="引入逆向工程的配置文件generatorConfig.xml并配置"></a>引入逆向工程的配置文件generatorConfig.xml并配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql 连接数据库jar 这里选择自己本地位置;</span></span><br><span class="line"><span class="comment">    如果不知道maven本地仓库地址，可以使用EveryThing工具全局搜索mysql-connector-java，找到jar包位置；</span></span><br><span class="line"><span class="comment">    也可以手动下载一个jar放在指定位置，进行引用。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;testTables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释,true：是,false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/medtrk_weather&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和</span></span><br><span class="line"><span class="comment">           NUMERIC 类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定javaBean生成的位置</span></span><br><span class="line"><span class="comment">            targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；</span></span><br><span class="line"><span class="comment">            targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;domain&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;autogenerator\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false；如果多个数据库改为true分目录 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--  指定mapper映射文件生成的位置</span></span><br><span class="line"><span class="comment">           targetPackage、targetProject同javaModelGenerator中作用一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapping&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;autogenerator\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定mapper接口生成的位置</span></span><br><span class="line"><span class="comment">         targetPackage、targetProject同javaModelGenerator中作用一样</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;autogenerator\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库表</span></span><br><span class="line"><span class="comment">        domainObjectName：生成的domain类的名字,当表名和domain类的名字有差异时一定要设置，如果不设置，直接使用表名作为domain类的名字；</span></span><br><span class="line"><span class="comment">        可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;weather_location&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Location&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="引入逆向工程的启动类并配置"><a href="#引入逆向工程的启动类并配置" class="headerlink" title="引入逆向工程的启动类并配置"></a>引入逆向工程的启动类并配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorSqlmap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//指定 逆向工程配置文件</span></span><br><span class="line">        File configFile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\HTR\\code_svn\\MedTrack\\autogenerator\\src\\main\\resources\\generatorConfig.xml&quot;</span>);</span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(<span class="keyword">true</span>);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config,</span><br><span class="line">                callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        mybatis 逆向生成启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            GeneratorSqlmap generatorSqlmap = <span class="keyword">new</span> GeneratorSqlmap();</span><br><span class="line">            generatorSqlmap.generator();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ进阶-参数</title>
    <url>/2021/11/08/RabbitMQ%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="mandatory参数"><a href="#mandatory参数" class="headerlink" title="mandatory参数"></a>mandatory参数</h2><p>当 mandatory 参数设为 true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么 RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者。当 mandatory 参数设置为 false 时，出现上述情形，则消息直接被丢弃。<br>生产者可以通过channel.addReturnListener添加ReturnListener监听器获取到信息有没有被正确的路由到合适的队列</p>
<h2 id="immediate参数"><a href="#immediate参数" class="headerlink" title="immediate参数"></a>immediate参数</h2><p>当 immediate 参数设为 true 时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过 Basic.Return 返回至生产者。<br>RabbitMQ 3.0 版本开始去掉了对 immediate 参数的支持</p>
<p>mandatory参数确保消息进入合适的队列，immediate参数确保进入队列的消息被消费</p>
<h2 id="备份交换器"><a href="#备份交换器" class="headerlink" title="备份交换器"></a>备份交换器</h2><p>英文名 Alternate Exchange，简称 AE，可以将未被路由的消息存储在 RabbitMQ 中，再在需要的时候去处理这些消息。</p>
<ul>
<li>如果设置的备份交换器不存在，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>
<li>如果备份交换器没有绑定任何队列，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>
<li>如果备份交换器没有任何匹配的队列，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>
<li>如果备份交换器和 mandatory 参数一起使用，那么 mandatory 参数无效。</li>
</ul>
<h2 id="过期时间-TTL"><a href="#过期时间-TTL" class="headerlink" title="过期时间(TTL)"></a>过期时间(TTL)</h2><p>Time to Live </p>
<h3 id="消息的过期时间"><a href="#消息的过期时间" class="headerlink" title="消息的过期时间"></a>消息的过期时间</h3><h4 id="通过队列属性设置"><a href="#通过队列属性设置" class="headerlink" title="通过队列属性设置"></a>通过队列属性设置</h4><p>队列中所有消息都有相同的过期时间<br>channel.queueDeclare 方法中加入x-message-ttl 参数实现的，这个参数的单位是毫秒</p>
<h4 id="通过消息设置"><a href="#通过消息设置" class="headerlink" title="通过消息设置"></a>通过消息设置</h4><p>对消息本身单独设置过期时间<br>channel.basicPublish 方法中加入 expiration的属性参数，单位为毫秒</p>
<p>如果两种方法一起使用，则消息的 TTL 以两者之间较小的那个数值为准<br>如果将 TTL 设置为 0，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃</p>
<h3 id="队列的过期时间"><a href="#队列的过期时间" class="headerlink" title="队列的过期时间"></a>队列的过期时间</h3><p>通过 channel.queueDeclare 方法中的 x-expires 参数可以设置队列被自动删除前处于未使用状态的时间<br>未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过 Basic.Get 命令。<br>RabbitMQ 会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时。在RabbitMQ 重启后，持久化的队列的过期时间会被重新计算。</p>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>DLX，全称为 Dead-Letter-Exchange，可以称之为死信交换器，也有人称之为死信邮箱。当消息在一个队列中变成死信（dead message）之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。<br>死信:</p>
<ul>
<li>消息过期</li>
<li>消息被拒绝</li>
<li>队列到达最大长度</li>
</ul>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>等待一定时间后消费者消费消息<br>实现手法：消费者消费死信队列中的消息</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级高的队列具有较高的优先级，优先级高的消息具有消息优先被消费的权力<br>针对消费者消费速度有限的情况</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h4><p>RabbitMQ服务重启后，没有设置为持久化的交换机元数据会丢失，消息不会丢失</p>
<h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>RabbitMQ服务重启后，没有设置为持久化的队列和消息会丢失</p>
<h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>RabbitMQ服务重启后，没有设置为持久化的消息会丢失</p>
<p>消息和队列需要同时设置持久化才能生效<br>操作持久化主要用于因为服务器异常崩溃导致的消息丢失</p>
<h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>问题：消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢？</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring创建多项目</title>
    <url>/2021/11/18/Sping%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="搭建SpringBoot-Maven多模块项目"><a href="#搭建SpringBoot-Maven多模块项目" class="headerlink" title="搭建SpringBoot+Maven多模块项目"></a>搭建SpringBoot+Maven多模块项目</h2><p><a href="https://guozh.net/springboot-maven-multi-module/">传送门</a></p>
<h3 id="创建父项目"><a href="#创建父项目" class="headerlink" title="创建父项目"></a>创建父项目</h3><p>父项目是一个特殊的Spring项目，只需要pom.xml不需要初始化其它文件，所以可以修改type<br><img src="img.jpg" alt="父项目"><br>添加如下代码，如果显示jar，改为pom<br><code>&lt;packaging&gt;pom&lt;/packaging&gt;</code></p>
<h3 id="创建子项目"><a href="#创建子项目" class="headerlink" title="创建子项目"></a>创建子项目</h3><p>正常创建子项目</p>
<h3 id="修改父项目pom-xml"><a href="#修改父项目pom-xml" class="headerlink" title="修改父项目pom.xml"></a>修改父项目pom.xml</h3><p>添加以下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;子项目-core&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;子项目-web&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;子项目-admin&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>
<p>使用modules，可以在父工程一键打包，Maven 会分享我们的子模块和项目，按照子模块之间依赖关系，自动打包，我们就不用关心顺序。</p>
<h3 id="在子项目中依赖父项目"><a href="#在子项目中依赖父项目" class="headerlink" title="在子项目中依赖父项目"></a>在子项目中依赖父项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;com.父项目&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;juhe&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<h3 id="dependencyManagement-和-dependencies"><a href="#dependencyManagement-和-dependencies" class="headerlink" title="dependencyManagement 和 dependencies"></a>dependencyManagement 和 dependencies</h3><p>子工程会将父项目的所有依赖继承<br>dependencyManagement的作用是声明依赖，<em><strong>只声明不依赖</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<p>此时父工程并没有依赖这个jar，需要在子项目填写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>规范了版本号</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring参数校验</title>
    <url>/2021/11/30/Spring%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u010349272/article/details/107520021">原文地址</a></p>
<h3 id="首先在controller声明对数据进行校验"><a href="#首先在controller声明对数据进行校验" class="headerlink" title="首先在controller声明对数据进行校验"></a>首先在controller声明对数据进行校验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/url.json&quot;,method= &#123;RequestMethod.POST&#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;?&gt; xxmethod( <span class="meta">@RequestBody</span> <span class="meta">@Validated</span>  XoPO xoPo)     </span><br><span class="line">    <span class="keyword">throws</span> ParseException, UnsupportedEncodingException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在bean上声明需要校验的字段"><a href="#在bean上声明需要校验的字段" class="headerlink" title="在bean上声明需要校验的字段"></a>在bean上声明需要校验的字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XoPO</span></span>&#123;</span><br><span class="line">    <span class="meta">@validated</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderPerson&gt; personList;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(max=32,message=&quot;code is null&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="meta">@Size(max=32,message=&quot;product is null&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用的校验类型"><a href="#常用的校验类型" class="headerlink" title="常用的校验类型"></a>常用的校验类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AssertFalse</span> 校验<span class="keyword">false</span></span><br><span class="line"><span class="meta">@AssertTrue</span> 校验<span class="keyword">true</span></span><br><span class="line"><span class="meta">@DecimalMax(value=,inclusive=)</span> 小于等于value，inclusive=<span class="keyword">true</span>,是小于等于</span><br><span class="line"><span class="meta">@DecimalMin(value=,inclusive=)</span> 与上类似</span><br><span class="line"><span class="meta">@Max(value=)</span> 小于等于value</span><br><span class="line"><span class="meta">@Min(value=)</span> 大于等于value</span><br><span class="line"><span class="meta">@NotNull</span>  检查Null</span><br><span class="line"><span class="meta">@Past</span>  检查日期</span><br><span class="line"><span class="meta">@Pattern(regex=,flag=)</span>  正则</span><br><span class="line"><span class="meta">@Size(min=, max=)</span>  字符串，集合，map限制大小</span><br><span class="line"><span class="meta">@Validate</span> 对po实体类进行校验</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat入门-管理端口</title>
    <url>/2021/11/01/mycat%E5%85%A5%E9%97%A8-4/</url>
    <content><![CDATA[<h2 id="Reload-命令"><a href="#Reload-命令" class="headerlink" title="Reload 命令"></a>Reload 命令</h2><p><code>reload @@config;</code>该命令用于更新 schema.xml 配置文件，例如更新 schema.xml 文件后在命令窗口输入该命令，不用重启即可进行配置文件的更新<br><code>reload @@config_all;</code>该命令用于更新所有配置文件，不用重启即可进行配置文件的更新</p>
<h2 id="Show-命令"><a href="#Show-命令" class="headerlink" title="Show 命令"></a>Show 命令</h2><p><code>show @@datanode;</code>该命令用于查询显示 Mycat 数据节点列表，通过 <code>show @@datanode where schema = ?</code> 的方式查询指定逻辑库（区分大小写）的数据节点<br><code>show @@version;</code>查看版本<br><code>show @@connection;</code>查看连接信息<br><code>show @@backend;</code>查看后端连接状况<br><code>show @@cache;</code>查看mycat缓存<br><code>show @@datasource;</code>看数据状态，配置的读写服务器，如果配置了主从，或者多主可以切换</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>MyCat</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat入门-入门级别的查缺补漏</title>
    <url>/2021/11/08/mycat%E5%85%A5%E9%97%A8-5/</url>
    <content><![CDATA[<h3 id="全局序列号"><a href="#全局序列号" class="headerlink" title="全局序列号"></a>全局序列号</h3><p>数据切分后，原有的关系数据库中的主键约束在分布式条件下将无法使用，因此需要引入外部机制保证数据唯一性标识，这种保证全局性的数据唯一标识的机制就是全局序列号（sequence）。<br>全局序列号有 本地文件，数据库，本地时间戳，zk等方式</p>
<h3 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h3><p>相同的软件提供给不同的用户，数据隔离可以有效的提升访问速度，隔离手段有三种</p>
<h4 id="独立数据库服务"><a href="#独立数据库服务" class="headerlink" title="独立数据库服务"></a>独立数据库服务</h4><p>一个租户一个数据库服务</p>
<h4 id="独立数据库"><a href="#独立数据库" class="headerlink" title="独立数据库"></a>独立数据库</h4><p>多个租户一个数据库服务，在服务中分库</p>
<h4 id="共享数据库，共享数据架构"><a href="#共享数据库，共享数据架构" class="headerlink" title="共享数据库，共享数据架构"></a>共享数据库，共享数据架构</h4><p>使用分表，通过指定分表规则区分租户</p>
<h4 id="mycat多租户实现"><a href="#mycat多租户实现" class="headerlink" title="mycat多租户实现"></a>mycat多租户实现</h4><p>web修改</p>
<ul>
<li>登陆时记录租户id</li>
<li>修改jdbc实现，在sql中添加sql注释指定数据库。例如：/*!mycat : schema = test_01 */ sql</li>
</ul>
<p>使用mycat拦截sql并发送到相应数据库</p>
<h3 id="分片join"><a href="#分片join" class="headerlink" title="分片join"></a>分片join</h3><ul>
<li><p>避免使用 left join 和right join，使用inner join</p>
</li>
<li><p>在使用 Left join 或 Right join 时，ON 会优先执行，where 条件在最后执行，所以在使用过程中，条件尽可能的在 ON 语句中判断，减少 where 的执行</p>
</li>
<li><p>少用子查询，而用 join。</p>
</li>
</ul>
<p><strong>mycat实现join有四种</strong></p>
<ol>
<li><strong>全局表</strong><br>全局表是数据冗余的，在每个节点上都有</li>
<li><strong>ER join</strong><br>将join数据的放到同一个节点上<br>分片在 dn1,dn2 上，orders 依赖父表进行分片，两个表的关联关系为 orders.customer_id=customer.id。于是数据分片和存储的示意图如下：<br><img src="img.png" alt="img.png"></li>
<li>Share join<br>只支持两个表的join，拆分成单表的sql执行，再把数据汇集</li>
<li>catlet（人工智能）<br>没看懂</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>MyCat</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat进阶</title>
    <url>/2021/11/10/mycat%E8%BF%9B%E9%98%B6-1/</url>
    <content><![CDATA[<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p><strong>前提：</strong> 正常情况下，Insert SQL需要几十毫秒的写入时间，而某些Select SQL需要几秒到几分钟才能有结果</p>
<p>在没有读写分离的系统上，很多复杂的SQL会很快的消耗CPU资源，系统陷入瘫痪<br>对于MYSQL而言，标准的读写分离是主从模式，一个写节点Master后面跟随多个读节点，读节点取决于系统压力，一般是1-3个</p>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><ol>
<li>在主库上记录二进制日志(将主库更新的事件记录)，在通知存储引擎在主库上执行更新</li>
<li>备库将主库的二进制日志复制(没有可以复制的会陷入睡眠，等待主库发送信号量唤醒)，记录到中继日志</li>
<li>备库读取中继日志并执行</li>
</ol>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="MySQL高可用方案"><a href="#MySQL高可用方案" class="headerlink" title="MySQL高可用方案"></a>MySQL高可用方案</h3><ol>
<li>MySQL Cluster</li>
<li>HeartBeat</li>
<li>Lvs+Keepalived</li>
<li>MariaDB Galera</li>
</ol>
<h3 id="MyCat高可用方案"><a href="#MyCat高可用方案" class="headerlink" title="MyCat高可用方案"></a>MyCat高可用方案</h3><p>建议采用标准的MySQL主从复制的高可用配置交付给MyCat完成MySQL的主从自动切换<br>HAproxy+Mycat 集群+MySQL 主从 如果还担心HAproxy 的稳定性和单点问题，则可以用 keepalived 的VIP的浮动功能</p>
<h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><p>看不懂啊</p>
<h2 id="MyCat拦截"><a href="#MyCat拦截" class="headerlink" title="MyCat拦截"></a>MyCat拦截</h2><p>用户可以写一个java类，将传入MyCat的SQL进行改写，然后交给MyCat执行，可以：</p>
<ul>
<li>捕获和记录某些特殊SQL</li>
<li>改变查询条件的顺序性能优化</li>
<li>某些Select SQL走读写分离</li>
</ul>
<h2 id="MyCat注解"><a href="#MyCat注解" class="headerlink" title="MyCat注解"></a>MyCat注解</h2><p>注解用来确定执行的分片<br>注解支持的’!’不被 mysql 单库兼容，<br>注解支持的’#’不被 mybatis 兼容<br>新增加 mycat 字符前缀标志 Hintsql:”/** mycat: */“<br>具体看文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/*#mycat:db_type=master*/ select * from travelrecord</span><br><span class="line">/*!mycat:db_type=slave*/ select * from travelrecord</span><br><span class="line">/**mycat:db_type=master*/ select * from travelrecord</span><br></pre></td></tr></table></figure>
<p><a href="http://www.mycat.org.cn/document/mycat-definitive-guide.pdf">在线PDF</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>MyCat</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-Excel</title>
    <url>/2021/11/03/%E9%9A%8F%E7%AC%94-Excel/</url>
    <content><![CDATA[<p>调研返回价格文档使用Excel展示更直观<br><a href="https://zhuanlan.zhihu.com/p/356471052#:~:text=Excel%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E8%A1%A8%E6%A0%BC%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%20%E4%B8%80%E3%80%81Excel%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F%201%E3%80%81%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E5%86%85%E5%AE%B9%E5%85%AC%E5%BC%8F%EF%BC%9A%3DIF%20%28COUNTIF%20%28A%3AA%2CA2%29%3E1%2C%22%E9%87%8D%E5%A4%8D%22%2C%22%22%29%E3%80%82.%202%E3%80%81%E7%94%A8%E5%87%BA%E7%94%9F%E5%B9%B4%E6%9C%88%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%B9%B4%E9%BE%84%E5%85%AC%E5%BC%8F%EF%BC%9A%3DTRUNC%20%28,%28DAYS360%20%28H6%2C%22200%E2%80%A6.%20Excel%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%A0%E7%94%A8%E8%BF%87cell%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F.%20excel%E4%B8%AD%E7%9A%84%E7%A5%9E%E7%A7%98%E9%AB%98%E6%89%8B.%20CELL%E5%87%BD%E6%95%B0%E6%98%AFexcel%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%A7%98%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%83%E5%B9%B6%E4%B8%8D%E5%83%8FSUM%E5%87%BD%E6%95%B0%E3%80%81VLOOKUP%E5%87%BD%E6%95%B0%E7%AD%89%E9%82%A3%E4%B9%88%E5%B8%B8%E7%94%A8%EF%BC%8C%E4%BD%86%E5%AE%83%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8D%B4%E9%9D%9E%E5%B8%B8%E5%BC%BA%E5%A4%A7%EF%BC%8C%E8%80%8C%E4%B8%94%E5%AE%9E%E7%94%A8%E3%80%82.%20CELL%E5%87%BD%E6%95%B0%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E3%80%81%E4%BD%8D%E7%BD%AE%E6%88%96%E5%86%85%E5%AE%B9%E7%9A%84%E6%9C%89%E5%85%B3%E4%BF%A1%E6%81%AF%E3%80%82.%20CELL%EF%BC%88%E2%80%A6.">常用Excel公式</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-数据字典</title>
    <url>/2021/11/08/%E9%9A%8F%E7%AC%94-%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="死信"><a href="#死信" class="headerlink" title="死信"></a>死信</h3><p>死信:</p>
<ul>
<li>消息过期</li>
<li>消息被拒绝</li>
<li>队列到达最大长度<br><del>消息在队列中的生存时间超过指定的过期时间(TTL)时，被称为死信</del><br>消费者无法收到的消息</li>
</ul>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>DLX，全称为 Dead-Letter-Exchange，可以称之为死信交换器，也有人称之为死信邮箱。当消息在一个队列中变成死信（dead message）之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。<br>正常的交换器，通过指定属性实现队列中死信的转发，转发后的队列就是死信队列</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-GROUP_CONCAT函数实现一对多，按一搜索</title>
    <url>/2022/04/11/mysql-GROUP-CONCAT%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E6%8C%89%E4%B8%80%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>背景：在某个界面上，需要显示随访列表，并且这次随访拥有多种用药的依从性<br>需求：我希望用一条sql语句查出我想要的结果<br>难点：一般的join会按一对多中的多为记录条数，但这里希望按一，因为会有分页排序等需求<br>解决方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	opf1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	org_patient_info <span class="keyword">AS</span> opi</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">			( <span class="keyword">SELECT</span> uuid, GROUP_CONCAT( medicine_compliance <span class="keyword">ORDER</span> <span class="keyword">BY</span> medicine_compliance <span class="keyword">DESC</span> SEPARATOR <span class="string">&#x27;;&#x27;</span> ) <span class="keyword">FROM</span> org_patient_followup1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> uuid ) </span><br><span class="line">	<span class="keyword">AS</span> opf1 <span class="keyword">ON</span> opi.uuid <span class="operator">=</span> opf1.uuid</span><br></pre></td></tr></table></figure>
<h3 id="完整语法如下"><a href="#完整语法如下" class="headerlink" title="完整语法如下"></a>完整语法如下</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">group_concat([<span class="keyword">DISTINCT</span>] 要连接的字段 [<span class="keyword">Order</span> <span class="keyword">BY</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span> 排序字段] [Separator <span class="string">&#x27;分隔符&#x27;</span>])</span><br><span class="line">可设置分隔符</span><br><span class="line"><span class="keyword">SELECT</span> id,GROUP_CONCAT(score SEPARATOR <span class="string">&#x27;;&#x27;</span>) <span class="keyword">FROM</span> testgroup <span class="keyword">GROUP</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>

<p>效果：会把‘多’的字段放到‘一’的一个字段中，使用分隔符划分</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-架构1</title>
    <url>/2022/04/11/%E9%9A%8F%E7%AC%94-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>xxlJob</title>
    <url>/2022/01/24/xxlJob/</url>
    <content><![CDATA[<p>原文:<a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>xxlJob</category>
      </categories>
      <tags>
        <tag>xxlJob</tag>
        <tag>分部署任务调度</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ初感-实操</title>
    <url>/2021/09/10/RabbitMQ%E5%88%9D%E6%84%9F-2/</url>
    <content><![CDATA[<h2 id="六种消息模型"><a href="#六种消息模型" class="headerlink" title="六种消息模型"></a>六种消息模型</h2><h3 id="基本消息模型-点对点模式"><a href="#基本消息模型-点对点模式" class="headerlink" title="基本消息模型 (点对点模式)"></a>基本消息模型 (点对点模式)</h3><h4 id="一对一-多对一"><a href="#一对一-多对一" class="headerlink" title="一对一 (多对一)"></a>一对一 (多对一)</h4><p><img src="%E9%9A%8F%E7%AC%94-%E6%95%B0%E6%8D%AE%E5%BA%93/img.png" alt="基本消息模型"></p>
<blockquote>
<p>P:生产者<br>C:消费者<br>Queue:消息队列</p>
</blockquote>
<h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>新建一个maven工程，添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.7.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h5 id="连接工具类"><a href="#连接工具类" class="headerlink" title="连接工具类"></a>连接工具类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;x.x.x.x&quot;</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(xxxx);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;my_vhost&quot;</span>);<span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过工厂获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3、声明（创建）队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4、消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">// 向指定的队列中发送消息</span></span><br><span class="line">        <span class="comment">//参数：String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为&quot;&quot;）</span></span><br><span class="line"><span class="comment">         * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</span></span><br><span class="line"><span class="comment">         * 3、props，消息的属性</span></span><br><span class="line"><span class="comment">         * 4、body，消息内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭通道和连接(资源关闭最好用try-catch-finally语句处理)</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对应的web管理网站<img src="img_1.png" alt="消息队列"></p>
<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;htr_test1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当接收到消息后此方法将被调用</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 信封，通过envelope</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 消息属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 消息内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                String exchange = envelope.getExchange();</span><br><span class="line">                <span class="comment">//消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean autoAck, Consumer callback</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</span></span><br><span class="line"><span class="comment">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息被消费掉了<img src="img_2.png" alt="消息队列"></p>
<h4 id="消息确认机制-ACK"><a href="#消息确认机制-ACK" class="headerlink" title="消息确认机制(ACK)"></a>消息确认机制(ACK)</h4><p>消息被消费者接收，队列中的消息就被删除，如果消费者收到消息出现异常没有对消息进行有效的操作呢<br>RabbitMQ有消息确认机制(ACK)，消费者操作之后，回想RabbitMQ回执ACK告知消息被接受，ACK分以下两种</p>
<ul>
<li>自动ACK 消息被接收自动发送ACK (可能收到消息，在处理的过程中异常，然后造成消息丢失)</li>
<li>手动ACK 手动编写代码发送ACK (对消息处理后发送ACK，出现异常时消息在消息队列中存在)<br>使用场景：</li>
<li>如果消息不重要，丢失也没有影响，自动ACK比较方便</li>
<li>如果消息重要，建议手动ACK<br>将自动ACK改为手动ACK，需要修改<code> channel.basicConsume(QUEUE_NAME, false, consumer);</code>第二个参数为false<br>然后在消息处理后加上 <code>channel.basicAck(envelope.getDeliveryTag(), false);</code>进行手动ACK<br>ACK的过程就是告诉消息队列，可以删除消息的过程 ，如果关闭自动ACK且没有手动ACK的话，当关闭消费者的时候，消息队列中的消息将恢复 (没有被消费)<h4 id="一对多-多对多"><a href="#一对多-多对多" class="headerlink" title="一对多 (多对多)"></a>一对多 (多对多)</h4><img src="img_3.png" alt="一对多"><br>两个消费者同事消费一个队列中的消息，其中消费者1处理比较耗时<h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5>生产者发送50条消息<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String message = <span class="string">&quot;task .. &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            Thread.sleep(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h5>消费者1 设置1秒处理一条消息<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                <span class="comment">//模拟任务耗时1s</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
消费者2和消费者1代码相同，去掉任务耗时即可<br>任务启动结果如下<br><img src="img_4.png" alt="消费者1"><img src="img_5.png" alt="消费者2"><br>两个消费者各消费了不同的25条消息，但由于消费者1处理事情时间较长，导致任务整体的时间依赖于消费者1的时间，那么怎么对这种情况进行改变呢<br>需要把任务进行按时间消费，消费越快的人，消费的越多<br>在声明队列之后，添加 <code>channel.basicQos(1);</code> 设置prefetchCount = 1,<br>设置的是单个消费者在同一时间段最多处理一个消息，在没有收到该消费者的ACK之前，不会将新的消息分发给他，而会把消息分给不在忙碌的下一个消费者 (自动ACK不生效)<br>再次测试<br><img src="img_6.png" alt="消费者1"><img src="img_7.png" alt="消费者2"></li>
</ul>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><ol>
<li>一个生产者多个消费者 (一对一无意义)</li>
<li>每个消费者都有一个自己的队列</li>
<li>生产者将信息发送给交换机，转发给队列，实现一个消息被多个消费者消费</li>
<li>队列绑定交换机</li>
</ol>
<p>交换机类型有以下四种： </p>
<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
<li>Header：header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。<h4 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h4>交换机类型：Fanout，也称为广播,和RoutingKey,BindingKey无关，消息发送到与交换机绑定的所有队列中<br><img src="img_8.png" alt="广播"><h5 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h5>和点对点模式不同：</li>
</ul>
<ol>
<li>声明交换机</li>
<li>发送消息到交换机<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_fanout_exchange&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;发送消息！！&quot;</span>;</span><br><span class="line">        <span class="comment">// 发布消息到Exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [生产者] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h5>消费者1在收到消息之后会执行短信通知<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;fanout_exchange_queue_sms&quot;</span>;<span class="comment">//短信队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_fanout_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [短信服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h5><p>消费者2在收到消息之后会执行邮件通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;fanout_exchange_queue_email&quot;</span>;<span class="comment">//邮件队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_fanout_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [邮件服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="img_9.png" alt="消费者1"><img src="img_10.png" alt="消费者2"></p>
<h4 id="direc"><a href="#direc" class="headerlink" title="direc"></a>direc</h4><p><img src="img_11.png" alt="路由模式"><br>会指定一个RoutingKey，交换机把消息发送给和RoutingKey完全匹配的队列</p>
<h5 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 消息内容，</span></span><br><span class="line">        String message = <span class="string">&quot;注册成功！请短信回复[T]退订&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;sms&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者1-1"><a href="#消费者1-1" class="headerlink" title="消费者1"></a>消费者1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;direct_exchange_queue_sms&quot;</span>;<span class="comment">//短信队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;sms&quot;</span>);<span class="comment">//指定接收发送方指定routing key为sms的消息</span></span><br><span class="line">        <span class="comment">//channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;email&quot;);</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [短信服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者2-1"><a href="#消费者2-1" class="headerlink" title="消费者2"></a>消费者2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;direct_exchange_queue_email&quot;</span>;<span class="comment">//邮件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;email&quot;</span>);<span class="comment">//指定接收发送方指定routing key为email的消息</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [邮件服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息，发现只有消费者1收到消息!<br><a href="img_12.png">指定路由收到消息</a></p>
<h4 id="topics"><a href="#topics" class="headerlink" title="topics"></a>topics</h4><p>和路由模式类似，多了通配符规则</p>
<blockquote>
<p>通配符规则：<br>#：匹配一个或多个词<br>*：匹配不多不少恰好1个词<br>举例：<br>audit.#：能够匹配audit.irs.corporate 或者 audit.irs<br>audit.*：只能匹配audit.irs</p>
</blockquote>
<p>以指定Routing key=”quick.orange.rabbit”为例，验证</p>
<h5 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_topic_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">&quot;这是一只行动迅速的橙色的兔子&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key为：quick.orange.rabbit</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [动物描述：] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者1-2"><a href="#消费者1-2" class="headerlink" title="消费者1"></a>消费者1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;topic_exchange_queue_Q1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_topic_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者2-2"><a href="#消费者2-2" class="headerlink" title="消费者2"></a>消费者2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;topic_exchange_queue_Q2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;test_topic_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;lazy.＃&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果消费者1和消费者2都收到消息了<br><img src="img_13.png" alt="消费者1收到消息"><img src="img_14.png" alt="消费者2收到消息"></p>
<h4 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h4><p><img src="img_15.png" alt="RPC模式"></p>
<blockquote>
<p>这块不是很明白，暂时理解成应用层的使用方法，归类到后台任务，异步任务那种</p>
</blockquote>
<p>基本概念：<br>RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。<br>流程说明：</p>
<ol>
<li>当客户端启动时，创建一个匿名的回调队列。</li>
<li>客户端为RPC请求设置2个属性：replyTo，设置回调队列名字；correlationId，标记request。</li>
<li>请求被发送到rpc_queue队列中。</li>
<li>RPC服务器端监听rpc_queue队列中的请求，当请求到来时，服务器端会处理并且把带有结果的消息发送给客户端。接收的队列就是replyTo设定的回调队列。</li>
<li>客户端监听回调队列，当有消息时，检查correlationId属性，如果与request中匹配，那就是结果了。<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4>持久化会将消息或内容存储在磁盘以防止RabbitMQb崩溃时数据的丢失<h5 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化<img src="img_16.png"></h5><h5 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化<img src="img_17.png"></h5><h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化<img src="img_18.png"></h5><del><a href="http://www.iamlintao.com/6427.html">代码参考博文</a></del><br><a href="https://www.cnblogs.com/bigberg/p/8195622.html">持久化参考博文</a><br><a href="https://www.rabbitmq.com/">RabbitMQ官网地址</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
